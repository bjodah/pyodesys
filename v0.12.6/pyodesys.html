

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyodesys package &mdash; pyodesys 0.12.6 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pyodesys.native package" href="pyodesys.native.html" />
    <link rel="prev" title="Welcome to pyodesys’s documentation!" href="index.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pyodesys
          

          
          </a>

          
            
            
              <div class="version">
                0.12.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">pyodesys package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="pyodesys.native.html">pyodesys.native package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyodesys.analysis">pyodesys.analysis module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyodesys.convergence">pyodesys.convergence module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyodesys.core">pyodesys.core module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyodesys.integrators">pyodesys.integrators module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyodesys.plotting">pyodesys.plotting module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyodesys.results">pyodesys.results module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyodesys.symbolic">pyodesys.symbolic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyodesys.util">pyodesys.util module</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyodesys</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>pyodesys package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/pyodesys.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pyodesys">
<span id="pyodesys-package"></span><h1>pyodesys package<a class="headerlink" href="#module-pyodesys" title="Permalink to this headline">¶</a></h1>
<p>Straightforward numerical integration of ODE systems from Python.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">pyodesys</span></code> package for enables intuitive solving of systems
of first order differential equations numerically. The system may be
symbolically defined.</p>
<p><code class="docutils literal notranslate"><span class="pre">pyodesys</span></code> ties computer algebra systems (like SymPy and symengine), and
numerical solvers (such as ODEPACK in SciPy, CVode in sundials, GSL or odeint)
together.</p>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyodesys.native.html">pyodesys.native package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pyodesys.native.html#pyodesys-native">pyodesys.native</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyodesys.native.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyodesys.native.html#module-pyodesys.native.cvode">pyodesys.native.cvode module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyodesys.native.html#module-pyodesys.native.gsl">pyodesys.native.gsl module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyodesys.native.html#module-pyodesys.native.odeint">pyodesys.native.odeint module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyodesys.native.html#module-pyodesys.native.util">pyodesys.native.util module</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyodesys.analysis">
<span id="pyodesys-analysis-module"></span><h2>pyodesys.analysis module<a class="headerlink" href="#module-pyodesys.analysis" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyodesys.convergence">
<span id="pyodesys-convergence-module"></span><h2>pyodesys.convergence module<a class="headerlink" href="#module-pyodesys.convergence" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyodesys.convergence.fit_factory">
<code class="sig-prename descclassname">pyodesys.convergence.</code><code class="sig-name descname">fit_factory</code><span class="sig-paren">(</span><em class="sig-param">discard=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/convergence.html#fit_factory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.convergence.fit_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyodesys.convergence.integrate_tolerance_series">
<code class="sig-prename descclassname">pyodesys.convergence.</code><code class="sig-name descname">integrate_tolerance_series</code><span class="sig-paren">(</span><em class="sig-param">odesys</em>, <em class="sig-param">atols</em>, <em class="sig-param">rtols</em>, <em class="sig-param">x</em>, <em class="sig-param">y0</em>, <em class="sig-param">params=()</em>, <em class="sig-param">fit=&lt;function &lt;lambda&gt; at 0x7fc3bb790ae8&gt;</em>, <em class="sig-param">val=&lt;function polyval at 0x7fc3c32bd7b8&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/convergence.html#integrate_tolerance_series"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.convergence.integrate_tolerance_series" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>odesys</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ODESys</span></code></span></dt><dd></dd>
<dt><strong>atols</strong><span class="classifier">array_like</span></dt><dd><p>Positive, monotonically increasing 1D array.</p>
</dd>
<dt><strong>rtols</strong><span class="classifier">array_like</span></dt><dd><p>Positive, monotonically increasing 1D array.</p>
</dd>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Passed on to <code class="docutils literal notranslate"><span class="pre">odesys.integrate</span></code> for first set of tolerances.
(subsequent calls will use xout from first integration).</p>
</dd>
<dt><strong>y0</strong><span class="classifier">array_like</span></dt><dd><p>Passed on to <code class="docutils literal notranslate"><span class="pre">odesys.integrate</span></code>.</p>
</dd>
<dt><strong>params</strong><span class="classifier">array_like</span></dt><dd><p>Passed on to <code class="docutils literal notranslate"><span class="pre">odesys.integrate</span></code>.</p>
</dd>
<dt><strong>fit</strong><span class="classifier">callable</span></dt><dd></dd>
<dt><strong>val</strong><span class="classifier">callable</span></dt><dd></dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Passed on to <code class="docutils literal notranslate"><span class="pre">odesys.integrate</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result0</strong><span class="classifier">Result</span></dt><dd></dd>
<dt><strong>results</strong><span class="classifier">list of Result instances</span></dt><dd></dd>
<dt><strong>extra</strong><span class="classifier">dict</span></dt><dd><p>errest : 2D array of error estimates for result0.yout</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyodesys.core">
<span id="pyodesys-core-module"></span><h2>pyodesys.core module<a class="headerlink" href="#module-pyodesys.core" title="Permalink to this headline">¶</a></h2>
<p>Core functionality for ODESys.</p>
<p>Note that it is possible to use new custom ODE integrators with pyodesys by
providing a module with two functions named <code class="docutils literal notranslate"><span class="pre">integrate_adaptive</span></code> and
<code class="docutils literal notranslate"><span class="pre">integrate_predefined</span></code>. See the <code class="docutils literal notranslate"><span class="pre">pyodesys.integrators</span></code> module for examples.</p>
<dl class="class">
<dt id="pyodesys.core.ODESys">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.core.</code><code class="sig-name descname">ODESys</code><span class="sig-paren">(</span><em class="sig-param">f</em>, <em class="sig-param">jac=None</em>, <em class="sig-param">dfdx=None</em>, <em class="sig-param">jtimes=None</em>, <em class="sig-param">first_step_cb=None</em>, <em class="sig-param">roots_cb=None</em>, <em class="sig-param">nroots=None</em>, <em class="sig-param">band=None</em>, <em class="sig-param">names=()</em>, <em class="sig-param">param_names=()</em>, <em class="sig-param">indep_name=None</em>, <em class="sig-param">description=None</em>, <em class="sig-param">dep_by_name=False</em>, <em class="sig-param">par_by_name=False</em>, <em class="sig-param">latex_names=()</em>, <em class="sig-param">latex_param_names=()</em>, <em class="sig-param">latex_indep_name=None</em>, <em class="sig-param">taken_names=None</em>, <em class="sig-param">pre_processors=None</em>, <em class="sig-param">post_processors=None</em>, <em class="sig-param">append_iv=False</em>, <em class="sig-param">autonomous_interface=None</em>, <em class="sig-param">to_arrays_callbacks=None</em>, <em class="sig-param">autonomous_exprs=None</em>, <em class="sig-param">_indep_autonomous_key=None</em>, <em class="sig-param">numpy=None</em>, <em class="sig-param">nnz=-1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#ODESys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.ODESys" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Object representing an ODE system.</p>
<p><code class="docutils literal notranslate"><span class="pre">ODESys</span></code> provides unified interface to:</p>
<ul class="simple">
<li><p>scipy.integarte.ode</p></li>
<li><p>pygslodeiv2</p></li>
<li><p>pyodeint</p></li>
<li><p>pycvodes</p></li>
</ul>
<p>The numerical integration can be performed either in an <a class="reference internal" href="#pyodesys.core.ODESys.adaptive" title="pyodesys.core.ODESys.adaptive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adaptive()</span></code></a>
or <a class="reference internal" href="#pyodesys.core.ODESys.predefined" title="pyodesys.core.ODESys.predefined"><code class="xref py py-meth docutils literal notranslate"><span class="pre">predefined()</span></code></a> mode. Where locations to report the solution is
chosen by the stepper or the user respectively. For convenience in user
code one may use <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a> which automatically chooses between
the two based on the length of <code class="docutils literal notranslate"><span class="pre">xout</span></code> provided by the user.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f</strong><span class="classifier">callback</span></dt><dd><p>first derivatives of dependent variables (y) with respect to
dependent variable (x). Signature is any of:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rhs(x,</span> <span class="pre">y[:])</span> <span class="pre">-&gt;</span> <span class="pre">f[:]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rhs(x,</span> <span class="pre">y[:],</span> <span class="pre">p[:])</span> <span class="pre">-&gt;</span> <span class="pre">f[:]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rhs(x,</span> <span class="pre">y[:],</span> <span class="pre">p[:],</span> <span class="pre">backend=math)</span> <span class="pre">-&gt;</span> <span class="pre">f[:]</span></code>.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>jac</strong><span class="classifier">callback</span></dt><dd><p>Jacobian matrix (dfdy). Required for implicit methods.
Signature should be either of:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">jac(x,</span> <span class="pre">y[:])</span> <span class="pre">-&gt;</span> <span class="pre">J</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jac(x,</span> <span class="pre">y[:],</span> <span class="pre">p[:])</span> <span class="pre">-J</span></code>.</p></li>
</ul>
</div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">nnz</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">J</span></code> should be a 2D array-like object if <code class="docutils literal notranslate"><span class="pre">nnz</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>
corresponding to a dense or banded jacobian (see also <code class="docutils literal notranslate"><span class="pre">band</span></code>).
If <code class="docutils literal notranslate"><span class="pre">nnz</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">J</span></code> should be an instance of <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csc_matrix</span></code>.</p>
</dd>
<dt><strong>dfdx</strong><span class="classifier">callback</span></dt><dd><p>Signature <code class="docutils literal notranslate"><span class="pre">dfdx(x,</span> <span class="pre">y[:],</span> <span class="pre">p[:])</span> <span class="pre">-&gt;</span> <span class="pre">out[:]</span></code> (used by e.g. GSL)</p>
</dd>
<dt><strong>jtimes</strong><span class="classifier">callback</span></dt><dd><p>Jacobian-vector product (Jv). Signature is <code class="docutils literal notranslate"><span class="pre">`jtimes(x,</span> <span class="pre">y[:],</span> <span class="pre">v[:])</span> <span class="pre">-&gt;</span> <span class="pre">Jv[:]`</span></code>
This is supported only by <code class="docutils literal notranslate"><span class="pre">cvode</span></code>.</p>
</dd>
<dt><strong>first_step_cb</strong><span class="classifier">callback</span></dt><dd><p>Signature <code class="docutils literal notranslate"><span class="pre">step1st(x,</span> <span class="pre">y[:],</span> <span class="pre">p[:])</span> <span class="pre">-&gt;</span> <span class="pre">dx0</span></code> (pass first_step==0 to use).
This is available for <code class="docutils literal notranslate"><span class="pre">cvode</span></code>, <code class="docutils literal notranslate"><span class="pre">odeint</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">gsl</span></code>, but not for <code class="docutils literal notranslate"><span class="pre">scipy</span></code>.</p>
</dd>
<dt><strong>roots_cb</strong><span class="classifier">callback</span></dt><dd><p>Signature <code class="docutils literal notranslate"><span class="pre">roots_cb(x,</span> <span class="pre">y[:],</span> <span class="pre">p[:]=(),</span> <span class="pre">backend=math)</span> <span class="pre">-&gt;</span> <span class="pre">discr[:]</span></code>.</p>
</dd>
<dt><strong>nroots</strong><span class="classifier">int</span></dt><dd><p>Length of return vector from <code class="docutils literal notranslate"><span class="pre">roots_cb</span></code>.</p>
</dd>
<dt><strong>band</strong><span class="classifier">tuple of 2 integers or None (default: None)</span></dt><dd><p>If jacobian is banded: number of sub- and super-diagonals</p>
</dd>
<dt><strong>names</strong><span class="classifier">iterable of strings (default</span></dt><dd><p>Names of variables, used for referencing dependent variables by name
and for labels in plots.</p>
</dd>
<dt><strong>param_names</strong><span class="classifier">iterable of strings (default: None)</span></dt><dd><p>Names of the parameters, used for referencing parameters by name.</p>
</dd>
<dt><strong>indep_name</strong><span class="classifier">str</span></dt><dd><p>Name of the independent variable</p>
</dd>
<dt><strong>dep_by_name</strong><span class="classifier">bool</span></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">True</span></code> <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a> expects a dictionary as input for y0.</p>
</dd>
<dt><strong>par_by_name</strong><span class="classifier">bool</span></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">True</span></code> <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a> expects a dictionary as input for params.</p>
</dd>
<dt><strong>latex_names</strong><span class="classifier">iterable of strings (default</span></dt><dd><p>Names of variables in LaTeX format (e.g. for labels in plots).</p>
</dd>
<dt><strong>latex_param_names</strong><span class="classifier">iterable of strings (default</span></dt><dd><p>Names of parameters in LaTeX format (e.g. for labels in plots).</p>
</dd>
<dt><strong>latex_indep_name</strong><span class="classifier">str</span></dt><dd><p>LaTeX formatted name of independent variable.</p>
</dd>
<dt><strong>taken_names</strong><span class="classifier">iterable of str</span></dt><dd><p>Names of dependent variables which are calculated in pre_processors</p>
</dd>
<dt><strong>pre_processors</strong><span class="classifier">iterable of callables (optional)</span></dt><dd><p>signature: f(x1[:], y1[:], params1[:]) -&gt; x2[:], y2[:], params2[:].
When modifying: insert at beginning.</p>
</dd>
<dt><strong>post_processors</strong><span class="classifier">iterable of callables (optional)</span></dt><dd><p>signature: f(x2[:], y2[:, :], params2[:]) -&gt; x1[:], y1[:, :],
params1[:]
When modifying: insert at end.</p>
</dd>
<dt><strong>append_iv</strong><span class="classifier">bool</span></dt><dd><p>See <code class="xref py py-attr docutils literal notranslate"><span class="pre">append_iv</span></code>.</p>
</dd>
<dt><strong>autonomous_interface</strong><span class="classifier">bool (optional)</span></dt><dd><p>If given, sets the <code class="xref py py-attr docutils literal notranslate"><span class="pre">autonomous_interface</span></code> to indicate whether
the system appears autonomous or not upon call to <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>.</p>
</dd>
<dt><strong>autonomous_exprs</strong><span class="classifier">bool</span></dt><dd><p>Describes whether the independent variable appears in the rhs expressions.
If set to <code class="docutils literal notranslate"><span class="pre">True</span></code> the underlying solver is allowed to shift the
independent variable during integration.</p>
</dd>
<dt><strong>nnz</strong><span class="classifier">int (default</span></dt><dd><p>Maximum number of non-zero entries in sparse jacobian. When
non-negative, jacobian is assumed to be dense or banded.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Banded jacobians are supported by “scipy” and “cvode” integrators.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">odesys</span> <span class="o">=</span> <span class="n">ODESys</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yout</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">odesys</span><span class="o">.</span><span class="n">predefined</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f_cb</strong><span class="classifier">callback</span></dt><dd><p>For evaluating the vector of derivatives.</p>
</dd>
<dt><strong>j_cb</strong><span class="classifier">callback or None</span></dt><dd><p>For evaluating the Jacobian matrix of f.</p>
</dd>
<dt><strong>dfdx_cb</strong><span class="classifier">callback or None</span></dt><dd><p>For evaluating the second order derivatives.</p>
</dd>
<dt><strong>jtimes_cb</strong><span class="classifier">callback or None</span></dt><dd><p>For evaluating the jacobian-vector product.</p>
</dd>
<dt><strong>first_step_cb</strong><span class="classifier">callback or None</span></dt><dd><p>For calculating the first step based on x0, y0 &amp; p.</p>
</dd>
<dt><strong>roots_cb</strong><span class="classifier">callback</span></dt><dd></dd>
<dt><strong>nroots</strong><span class="classifier">int</span></dt><dd></dd>
<dt><strong>nnz</strong><span class="classifier">int</span></dt><dd></dd>
<dt><strong>names</strong><span class="classifier">tuple of strings</span></dt><dd></dd>
<dt><strong>param_names</strong><span class="classifier">tuple of strings</span></dt><dd></dd>
<dt><strong>description</strong><span class="classifier">str</span></dt><dd></dd>
<dt><strong>dep_by_name</strong><span class="classifier">bool</span></dt><dd></dd>
<dt><strong>par_by_name</strong><span class="classifier">bool</span></dt><dd></dd>
<dt><strong>latex_names</strong><span class="classifier">tuple of str</span></dt><dd></dd>
<dt><strong>latex_param_names</strong><span class="classifier">tuple of str</span></dt><dd></dd>
<dt><strong>pre_processors</strong><span class="classifier">iterable of callbacks</span></dt><dd></dd>
<dt><strong>post_processors</strong><span class="classifier">iterable of callbacks</span></dt><dd></dd>
<dt><strong>append_iv</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> params[:] passed to <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_cb</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">jac_cb</span></code> will contain
initial values of y. Note that this happens after pre processors have been
applied.</p>
</dd>
<dt><strong>autonomous_interface</strong><span class="classifier">bool or None</span></dt><dd><p>Indicates whether the system appears autonomous upon call to
<a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>. <code class="docutils literal notranslate"><span class="pre">None</span></code> indicates that it is unknown.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.core.ODESys.adaptive" title="pyodesys.core.ODESys.adaptive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive</span></code></a>(self, y0, x0, xend[, params])</p></td>
<td><p>Integrate with integrator chosen output.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.core.ODESys.chained_parameter_variation" title="pyodesys.core.ODESys.chained_parameter_variation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chained_parameter_variation</span></code></a>(self, \*args, …)</p></td>
<td><p>See <a class="reference internal" href="#pyodesys.core.chained_parameter_variation" title="pyodesys.core.chained_parameter_variation"><code class="xref py py-func docutils literal notranslate"><span class="pre">chained_parameter_variation()</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate</span></code></a>(self, x, y0[, params, atol, rtol])</p></td>
<td><p>Integrate the system of ordinary differential equations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.core.ODESys.plot_phase_plane" title="pyodesys.core.ODESys.plot_phase_plane"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_phase_plane</span></code></a>(self[, indices])</p></td>
<td><p>Plots a phase portrait from last integration.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.core.ODESys.plot_result" title="pyodesys.core.ODESys.plot_result"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_result</span></code></a>(self, \*\*kwargs)</p></td>
<td><p>Plots the integrated dependent variables from last integration.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.core.ODESys.post_process" title="pyodesys.core.ODESys.post_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">post_process</span></code></a>(self, xout, yout, params)</p></td>
<td><p>Transforms internal values to output, used internally.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.core.ODESys.pre_process" title="pyodesys.core.ODESys.pre_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pre_process</span></code></a>(self, xout, y0[, params])</p></td>
<td><p>Transforms input to internal values, used internally.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.core.ODESys.predefined" title="pyodesys.core.ODESys.predefined"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predefined</span></code></a>(self, y0, xout[, params])</p></td>
<td><p>Integrate with user chosen output.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.core.ODESys.stiffness" title="pyodesys.core.ODESys.stiffness"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stiffness</span></code></a>(self[, xyp, eigenvals_cb])</p></td>
<td><p>[DEPRECATED] Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.stiffness()</span></code>, stiffness ration</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 57%" />
<col style="width: 43%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>to_arrays</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyodesys.core.ODESys.adaptive">
<code class="sig-name descname">adaptive</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">y0</em>, <em class="sig-param">x0</em>, <em class="sig-param">xend</em>, <em class="sig-param">params=()</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#ODESys.adaptive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.ODESys.adaptive" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate with integrator chosen output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>integrator</strong><span class="classifier">str</span></dt><dd><p>See <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">array_like</span></dt><dd><p>See <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">float</span></dt><dd><p>Initial value of the independent variable.</p>
</dd>
<dt><strong>xend</strong><span class="classifier">float</span></dt><dd><p>Final value of the independent variable.</p>
</dd>
<dt><strong>params</strong><span class="classifier">array_like</span></dt><dd><p>See <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>.</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>See <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Same as <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyodesys.core.ODESys.chained_parameter_variation">
<code class="sig-name descname">chained_parameter_variation</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#ODESys.chained_parameter_variation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.ODESys.chained_parameter_variation" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pyodesys.core.chained_parameter_variation" title="pyodesys.core.chained_parameter_variation"><code class="xref py py-func docutils literal notranslate"><span class="pre">chained_parameter_variation()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.core.ODESys.integrate">
<code class="sig-name descname">integrate</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">y0</em>, <em class="sig-param">params=()</em>, <em class="sig-param">atol=1e-08</em>, <em class="sig-param">rtol=1e-08</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#ODESys.integrate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.ODESys.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate the system of ordinary differential equations.</p>
<p>Solves the initial value problem (IVP).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like or pair (start and final time) or float</span></dt><dd><dl class="simple">
<dt>if float:</dt><dd><p>make it a pair: (0, x)</p>
</dd>
<dt>if pair or length-2 array:</dt><dd><p>initial and final value of the independent variable</p>
</dd>
<dt>if array_like:</dt><dd><p>values of independent variable report at</p>
</dd>
</dl>
</dd>
<dt><strong>y0</strong><span class="classifier">array_like</span></dt><dd><p>Initial values at x[0] for the dependent variables.</p>
</dd>
<dt><strong>params</strong><span class="classifier">array_like (default: tuple())</span></dt><dd><p>Value of parameters passed to user-supplied callbacks.</p>
</dd>
<dt><strong>integrator</strong><span class="classifier">str or None</span></dt><dd><dl class="simple">
<dt>Name of integrator, one of:</dt><dd><ul class="simple">
<li><p>‘scipy’: <code class="xref py py-meth docutils literal notranslate"><span class="pre">_integrate_scipy()</span></code></p></li>
<li><p>‘gsl’: <code class="xref py py-meth docutils literal notranslate"><span class="pre">_integrate_gsl()</span></code></p></li>
<li><p>‘odeint’: <code class="xref py py-meth docutils literal notranslate"><span class="pre">_integrate_odeint()</span></code></p></li>
<li><p>‘cvode’:  <code class="xref py py-meth docutils literal notranslate"><span class="pre">_integrate_cvode()</span></code></p></li>
</ul>
</dd>
</dl>
<p>See respective method for more information.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>: <code class="docutils literal notranslate"><span class="pre">os.environ.get('PYODESYS_INTEGRATOR',</span> <span class="pre">'scipy')</span></code></p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>Absolute tolerance</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float</span></dt><dd><p>Relative tolerance</p>
</dd>
<dt><strong>with_jacobian</strong><span class="classifier">bool or None (default)</span></dt><dd><p>Whether to use the jacobian. When <code class="docutils literal notranslate"><span class="pre">None</span></code> the choice is
done automatically (only used when required). This matters
when jacobian is derived at runtime (high computational cost).</p>
</dd>
<dt><strong>with_jtimes</strong><span class="classifier">bool (default: False)</span></dt><dd><p>Whether to use the jacobian-vector product. This is only supported
by <code class="docutils literal notranslate"><span class="pre">cvode</span></code> and only when <code class="docutils literal notranslate"><span class="pre">linear_solver</span></code> is one of: gmres’,
‘gmres_classic’, ‘bicgstab’, ‘tfqmr’. See the documentation
for <code class="docutils literal notranslate"><span class="pre">pycvodes</span></code> for more information.</p>
</dd>
<dt><strong>force_predefined</strong><span class="classifier">bool (default: False)</span></dt><dd><p>override behaviour of <code class="docutils literal notranslate"><span class="pre">len(x)</span> <span class="pre">==</span> <span class="pre">2</span></code> =&gt; <a class="reference internal" href="#pyodesys.core.ODESys.adaptive" title="pyodesys.core.ODESys.adaptive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adaptive()</span></code></a></p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Additional keyword arguments for <code class="docutils literal notranslate"><span class="pre">_integrate_$(integrator)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Length 3 tuple: (x, yout, info)</dt><dd><p>x : array of values of the independent variable
yout : array of the dependent variable(s) for the different</p>
<blockquote>
<div><p>values of x.</p>
</div></blockquote>
<p>info : dict (‘nfev’ is guaranteed to be a key)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyodesys.core.ODESys.plot_phase_plane">
<code class="sig-name descname">plot_phase_plane</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#ODESys.plot_phase_plane"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.ODESys.plot_phase_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a phase portrait from last integration.</p>
<p>This method will be deprecated. Please use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.plot_phase_plane()</span></code>.
See <a class="reference internal" href="#pyodesys.plotting.plot_phase_plane" title="pyodesys.plotting.plot_phase_plane"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyodesys.plotting.plot_phase_plane()</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.core.ODESys.plot_result">
<code class="sig-name descname">plot_result</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#ODESys.plot_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.ODESys.plot_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the integrated dependent variables from last integration.</p>
<p>This method will be deprecated. Please use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.plot()</span></code>.
See <a class="reference internal" href="#pyodesys.plotting.plot_result" title="pyodesys.plotting.plot_result"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyodesys.plotting.plot_result()</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.core.ODESys.post_process">
<code class="sig-name descname">post_process</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">xout</em>, <em class="sig-param">yout</em>, <em class="sig-param">params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#ODESys.post_process"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.ODESys.post_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms internal values to output, used internally.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.core.ODESys.pre_process">
<code class="sig-name descname">pre_process</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">xout</em>, <em class="sig-param">y0</em>, <em class="sig-param">params=()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#ODESys.pre_process"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.ODESys.pre_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms input to internal values, used internally.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.core.ODESys.predefined">
<code class="sig-name descname">predefined</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">y0</em>, <em class="sig-param">xout</em>, <em class="sig-param">params=()</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#ODESys.predefined"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.ODESys.predefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate with user chosen output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>integrator</strong><span class="classifier">str</span></dt><dd><p>See <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">array_like</span></dt><dd><p>See <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>.</p>
</dd>
<dt><strong>xout</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>params</strong><span class="classifier">array_like</span></dt><dd><p>See <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>.</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>See <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Length 2 tuple</strong><span class="classifier">(yout, info)</span></dt><dd><p>See <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyodesys.core.ODESys.stiffness">
<code class="sig-name descname">stiffness</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">xyp=None</em>, <em class="sig-param">eigenvals_cb=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#ODESys.stiffness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.ODESys.stiffness" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEPRECATED] Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.stiffness()</span></code>, stiffness ration</p>
<p>Running stiffness ratio from last integration.
Calculate sittness ratio, i.e. the ratio between the largest and
smallest absolute eigenvalue of the jacobian matrix. The user may
supply their own routine for calculating the eigenvalues, or they
will be calculated from the SVD (singular value decomposition).
Note that calculating the SVD for any but the smallest Jacobians may
prove to be prohibitively expensive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyp</strong><span class="classifier">length 3 tuple (default: None)</span></dt><dd><p>internal_xout, internal_yout, internal_params, taken
from last integration if not specified.</p>
</dd>
<dt><strong>eigenvals_cb</strong><span class="classifier">callback (optional)</span></dt><dd><p>Signature (x, y, p) (internal variables), when not provided an
internal routine will use <code class="docutils literal notranslate"><span class="pre">self.j_cb</span></code> and <code class="docutils literal notranslate"><span class="pre">scipy.linalg.svd</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyodesys.core.ODESys.to_arrays">
<code class="sig-name descname">to_arrays</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">p</em>, <em class="sig-param">callbacks=None</em>, <em class="sig-param">reshape=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#ODESys.to_arrays"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.ODESys.to_arrays" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyodesys.core.OdeSys">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.core.</code><code class="sig-name descname">OdeSys</code><span class="sig-paren">(</span><em class="sig-param">f</em>, <em class="sig-param">jac=None</em>, <em class="sig-param">dfdx=None</em>, <em class="sig-param">jtimes=None</em>, <em class="sig-param">first_step_cb=None</em>, <em class="sig-param">roots_cb=None</em>, <em class="sig-param">nroots=None</em>, <em class="sig-param">band=None</em>, <em class="sig-param">names=()</em>, <em class="sig-param">param_names=()</em>, <em class="sig-param">indep_name=None</em>, <em class="sig-param">description=None</em>, <em class="sig-param">dep_by_name=False</em>, <em class="sig-param">par_by_name=False</em>, <em class="sig-param">latex_names=()</em>, <em class="sig-param">latex_param_names=()</em>, <em class="sig-param">latex_indep_name=None</em>, <em class="sig-param">taken_names=None</em>, <em class="sig-param">pre_processors=None</em>, <em class="sig-param">post_processors=None</em>, <em class="sig-param">append_iv=False</em>, <em class="sig-param">autonomous_interface=None</em>, <em class="sig-param">to_arrays_callbacks=None</em>, <em class="sig-param">autonomous_exprs=None</em>, <em class="sig-param">_indep_autonomous_key=None</em>, <em class="sig-param">numpy=None</em>, <em class="sig-param">nnz=-1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#OdeSys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.OdeSys" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyodesys.core.ODESys" title="pyodesys.core.ODESys"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyodesys.core.ODESys</span></code></a></p>
<p>DEPRECATED, use ODESys instead.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive</span></code>(self, y0, x0, xend[, params])</p></td>
<td><p>Integrate with integrator chosen output.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">chained_parameter_variation</span></code>(self, \*args, …)</p></td>
<td><p>See <a class="reference internal" href="#pyodesys.core.chained_parameter_variation" title="pyodesys.core.chained_parameter_variation"><code class="xref py py-func docutils literal notranslate"><span class="pre">chained_parameter_variation()</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate</span></code>(self, x, y0[, params, atol, rtol])</p></td>
<td><p>Integrate the system of ordinary differential equations.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_phase_plane</span></code>(self[, indices])</p></td>
<td><p>Plots a phase portrait from last integration.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_result</span></code>(self, \*\*kwargs)</p></td>
<td><p>Plots the integrated dependent variables from last integration.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">post_process</span></code>(self, xout, yout, params)</p></td>
<td><p>Transforms internal values to output, used internally.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pre_process</span></code>(self, xout, y0[, params])</p></td>
<td><p>Transforms input to internal values, used internally.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">predefined</span></code>(self, y0, xout[, params])</p></td>
<td><p>Integrate with user chosen output.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">stiffness</span></code>(self[, xyp, eigenvals_cb])</p></td>
<td><p>[DEPRECATED] Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.stiffness()</span></code>, stiffness ration</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 57%" />
<col style="width: 43%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>to_arrays</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="exception">
<dt id="pyodesys.core.RecoverableError">
<em class="property">exception </em><code class="sig-prename descclassname">pyodesys.core.</code><code class="sig-name descname">RecoverableError</code><a class="reference internal" href="_modules/pyodesys/core.html#RecoverableError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.RecoverableError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="function">
<dt id="pyodesys.core.chained_parameter_variation">
<code class="sig-prename descclassname">pyodesys.core.</code><code class="sig-name descname">chained_parameter_variation</code><span class="sig-paren">(</span><em class="sig-param">subject</em>, <em class="sig-param">durations</em>, <em class="sig-param">y0</em>, <em class="sig-param">varied_params</em>, <em class="sig-param">default_params=None</em>, <em class="sig-param">integrate_kwargs=None</em>, <em class="sig-param">x0=None</em>, <em class="sig-param">npoints=1</em>, <em class="sig-param">numpy=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#chained_parameter_variation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.chained_parameter_variation" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate an ODE-system for a serie of durations with some parameters changed in-between</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>subject</strong><span class="classifier">function or ODESys instance</span></dt><dd><p>If a function: should have the signature of <code class="xref py py-meth docutils literal notranslate"><span class="pre">pyodesys.ODESys.integrate()</span></code>
(and resturn a <a class="reference internal" href="#pyodesys.results.Result" title="pyodesys.results.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyodesys.results.Result</span></code></a> object).
If a ODESys instance: the <code class="docutils literal notranslate"><span class="pre">integrate</span></code> method will be used.</p>
</dd>
<dt><strong>durations</strong><span class="classifier">iterable of floats</span></dt><dd><p>Spans of the independent variable.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">dict or array_like</span></dt><dd></dd>
<dt><strong>varied_params</strong><span class="classifier">dict mapping parameter name (or index) to array_like</span></dt><dd><p>Each array_like need to be of same length as durations.</p>
</dd>
<dt><strong>default_params</strong><span class="classifier">dict or array_like</span></dt><dd><p>Default values for the parameters of the ODE system.</p>
</dd>
<dt><strong>integrate_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Keyword arguments passed on to <code class="docutils literal notranslate"><span class="pre">integrate</span></code>.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">float-like</span></dt><dd><p>First value of independent variable. default: 0.</p>
</dd>
<dt><strong>npoints</strong><span class="classifier">int</span></dt><dd><p>Number of points per sub-interval.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">odesys</span> <span class="o">=</span> <span class="n">ODESys</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">integrator</span><span class="o">=</span><span class="s1">&#39;cvode&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;adams&#39;</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">default_params</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">integrate_kwargs</span><span class="o">=</span><span class="n">int_kw</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">chained_parameter_variation</span><span class="p">(</span><span class="n">odesys</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">42</span><span class="p">],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="mi">7</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">]},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask1</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">xout</span> <span class="o">&lt;=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">yout</span><span class="p">[</span><span class="n">mask1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">42</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-.</span><span class="mi">7</span><span class="o">*</span><span class="n">res</span><span class="o">.</span><span class="n">xout</span><span class="p">[</span><span class="n">mask1</span><span class="p">]))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">res</span><span class="o">.</span><span class="n">xout</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">yout</span><span class="p">[</span><span class="n">mask2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">res</span><span class="o">.</span><span class="n">yout</span><span class="p">[</span><span class="n">mask2</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">xout</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">-</span> <span class="n">res</span><span class="o">.</span><span class="n">xout</span><span class="p">[</span><span class="n">mask2</span><span class="p">][</span><span class="mi">0</span><span class="p">])))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyodesys.core.integrate_auto_switch">
<code class="sig-prename descclassname">pyodesys.core.</code><code class="sig-name descname">integrate_auto_switch</code><span class="sig-paren">(</span><em class="sig-param">odes</em>, <em class="sig-param">kw</em>, <em class="sig-param">x</em>, <em class="sig-param">y0</em>, <em class="sig-param">params=()</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/core.html#integrate_auto_switch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.core.integrate_auto_switch" title="Permalink to this definition">¶</a></dt>
<dd><p>Auto-switching between formulations of ODE system.</p>
<p>In case one has a formulation of a system of ODEs which is preferential in
the beginning of the integration, this function allows the user to run the
integration with this system where it takes a user-specified maximum number
of steps before switching to another formulation (unless final value of the
independent variables has been reached). Number of systems used i returned
as <code class="docutils literal notranslate"><span class="pre">nsys</span></code> in info dict.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>odes</strong><span class="classifier">iterable of <code class="xref py py-class docutils literal notranslate"><span class="pre">OdeSy</span></code> instances</span></dt><dd></dd>
<dt><strong>kw</strong><span class="classifier">dict mapping kwarg to iterables of same legnth as <code class="docutils literal notranslate"><span class="pre">odes</span></code></span></dt><dd></dd>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>y0</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>params</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>**kwargs:</strong></dt><dd><p>See <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ODESys.integrate()</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Plays particularly well with <code class="xref py py-class docutils literal notranslate"><span class="pre">symbolic.TransformedSys</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="pyodesys.core.integrate_chained">
<code class="sig-prename descclassname">pyodesys.core.</code><code class="sig-name descname">integrate_chained</code><span class="sig-paren">(</span><em class="sig-param">odes</em>, <em class="sig-param">kw</em>, <em class="sig-param">x</em>, <em class="sig-param">y0</em>, <em class="sig-param">params=()</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyodesys.core.integrate_chained" title="Permalink to this definition">¶</a></dt>
<dd><p>Auto-switching between formulations of ODE system.</p>
<p>In case one has a formulation of a system of ODEs which is preferential in
the beginning of the integration, this function allows the user to run the
integration with this system where it takes a user-specified maximum number
of steps before switching to another formulation (unless final value of the
independent variables has been reached). Number of systems used i returned
as <code class="docutils literal notranslate"><span class="pre">nsys</span></code> in info dict.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>odes</strong><span class="classifier">iterable of <code class="xref py py-class docutils literal notranslate"><span class="pre">OdeSy</span></code> instances</span></dt><dd></dd>
<dt><strong>kw</strong><span class="classifier">dict mapping kwarg to iterables of same legnth as <code class="docutils literal notranslate"><span class="pre">odes</span></code></span></dt><dd></dd>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>y0</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>params</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>**kwargs:</strong></dt><dd><p>See <a class="reference internal" href="#pyodesys.core.ODESys.integrate" title="pyodesys.core.ODESys.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ODESys.integrate()</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Plays particularly well with <code class="xref py py-class docutils literal notranslate"><span class="pre">symbolic.TransformedSys</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="module-pyodesys.integrators">
<span id="pyodesys-integrators-module"></span><h2>pyodesys.integrators module<a class="headerlink" href="#module-pyodesys.integrators" title="Permalink to this headline">¶</a></h2>
<p>This module is for demonstration purposes only and the integrators here
are not meant for production use. Consider them provisional, i.e., API here
may break without prior deprecation.</p>
<dl class="class">
<dt id="pyodesys.integrators.EulerBackward_example_integrator">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.integrators.</code><code class="sig-name descname">EulerBackward_example_integrator</code><a class="reference internal" href="_modules/pyodesys/integrators.html#EulerBackward_example_integrator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.integrators.EulerBackward_example_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>integrate_adaptive</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>integrate_predefined</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyodesys.integrators.EulerBackward_example_integrator.integrate_adaptive">
<code class="sig-name descname">integrate_adaptive</code><em class="property"> = None</em><a class="headerlink" href="#pyodesys.integrators.EulerBackward_example_integrator.integrate_adaptive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.integrators.EulerBackward_example_integrator.integrate_predefined">
<em class="property">static </em><code class="sig-name descname">integrate_predefined</code><span class="sig-paren">(</span><em class="sig-param">rhs</em>, <em class="sig-param">jac</em>, <em class="sig-param">y0</em>, <em class="sig-param">xout</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/integrators.html#EulerBackward_example_integrator.integrate_predefined"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.integrators.EulerBackward_example_integrator.integrate_predefined" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyodesys.integrators.EulerBackward_example_integrator.with_jacobian">
<code class="sig-name descname">with_jacobian</code><em class="property"> = True</em><a class="headerlink" href="#pyodesys.integrators.EulerBackward_example_integrator.with_jacobian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyodesys.integrators.EulerForward_example_integrator">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.integrators.</code><code class="sig-name descname">EulerForward_example_integrator</code><a class="reference internal" href="_modules/pyodesys/integrators.html#EulerForward_example_integrator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.integrators.EulerForward_example_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>integrate_adaptive</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>integrate_predefined</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyodesys.integrators.EulerForward_example_integrator.integrate_adaptive">
<code class="sig-name descname">integrate_adaptive</code><em class="property"> = None</em><a class="headerlink" href="#pyodesys.integrators.EulerForward_example_integrator.integrate_adaptive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.integrators.EulerForward_example_integrator.integrate_predefined">
<em class="property">static </em><code class="sig-name descname">integrate_predefined</code><span class="sig-paren">(</span><em class="sig-param">rhs</em>, <em class="sig-param">jac</em>, <em class="sig-param">y0</em>, <em class="sig-param">xout</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/integrators.html#EulerForward_example_integrator.integrate_predefined"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.integrators.EulerForward_example_integrator.integrate_predefined" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyodesys.integrators.EulerForward_example_integrator.with_jacobian">
<code class="sig-name descname">with_jacobian</code><em class="property"> = False</em><a class="headerlink" href="#pyodesys.integrators.EulerForward_example_integrator.with_jacobian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyodesys.integrators.Midpoint_example_integrator">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.integrators.</code><code class="sig-name descname">Midpoint_example_integrator</code><a class="reference internal" href="_modules/pyodesys/integrators.html#Midpoint_example_integrator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.integrators.Midpoint_example_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>integrate_adaptive</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>integrate_predefined</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyodesys.integrators.Midpoint_example_integrator.integrate_adaptive">
<code class="sig-name descname">integrate_adaptive</code><em class="property"> = None</em><a class="headerlink" href="#pyodesys.integrators.Midpoint_example_integrator.integrate_adaptive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.integrators.Midpoint_example_integrator.integrate_predefined">
<em class="property">static </em><code class="sig-name descname">integrate_predefined</code><span class="sig-paren">(</span><em class="sig-param">rhs</em>, <em class="sig-param">jac</em>, <em class="sig-param">y0</em>, <em class="sig-param">xout</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/integrators.html#Midpoint_example_integrator.integrate_predefined"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.integrators.Midpoint_example_integrator.integrate_predefined" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyodesys.integrators.Midpoint_example_integrator.with_jacobian">
<code class="sig-name descname">with_jacobian</code><em class="property"> = False</em><a class="headerlink" href="#pyodesys.integrators.Midpoint_example_integrator.with_jacobian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyodesys.integrators.RK4_example_integrator">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.integrators.</code><code class="sig-name descname">RK4_example_integrator</code><a class="reference internal" href="_modules/pyodesys/integrators.html#RK4_example_integrator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.integrators.RK4_example_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This is an example of how to implement a custom integrator.
It uses fixed step size and is usually not useful for real problems.</p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>integrate_adaptive</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>integrate_predefined</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyodesys.integrators.RK4_example_integrator.integrate_adaptive">
<em class="property">static </em><code class="sig-name descname">integrate_adaptive</code><span class="sig-paren">(</span><em class="sig-param">rhs</em>, <em class="sig-param">jac</em>, <em class="sig-param">y0</em>, <em class="sig-param">x0</em>, <em class="sig-param">xend</em>, <em class="sig-param">dx0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/integrators.html#RK4_example_integrator.integrate_adaptive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.integrators.RK4_example_integrator.integrate_adaptive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.integrators.RK4_example_integrator.integrate_predefined">
<em class="property">static </em><code class="sig-name descname">integrate_predefined</code><span class="sig-paren">(</span><em class="sig-param">rhs</em>, <em class="sig-param">jac</em>, <em class="sig-param">y0</em>, <em class="sig-param">xout</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/integrators.html#RK4_example_integrator.integrate_predefined"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.integrators.RK4_example_integrator.integrate_predefined" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyodesys.integrators.RK4_example_integrator.with_jacobian">
<code class="sig-name descname">with_jacobian</code><em class="property"> = False</em><a class="headerlink" href="#pyodesys.integrators.RK4_example_integrator.with_jacobian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyodesys.integrators.Trapezoidal_example_integrator">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.integrators.</code><code class="sig-name descname">Trapezoidal_example_integrator</code><a class="reference internal" href="_modules/pyodesys/integrators.html#Trapezoidal_example_integrator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.integrators.Trapezoidal_example_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>integrate_adaptive</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>integrate_predefined</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyodesys.integrators.Trapezoidal_example_integrator.integrate_adaptive">
<code class="sig-name descname">integrate_adaptive</code><em class="property"> = None</em><a class="headerlink" href="#pyodesys.integrators.Trapezoidal_example_integrator.integrate_adaptive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.integrators.Trapezoidal_example_integrator.integrate_predefined">
<em class="property">static </em><code class="sig-name descname">integrate_predefined</code><span class="sig-paren">(</span><em class="sig-param">rhs</em>, <em class="sig-param">jac</em>, <em class="sig-param">y0</em>, <em class="sig-param">xout</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/integrators.html#Trapezoidal_example_integrator.integrate_predefined"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.integrators.Trapezoidal_example_integrator.integrate_predefined" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyodesys.integrators.Trapezoidal_example_integrator.with_jacobian">
<code class="sig-name descname">with_jacobian</code><em class="property"> = True</em><a class="headerlink" href="#pyodesys.integrators.Trapezoidal_example_integrator.with_jacobian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyodesys.plotting">
<span id="pyodesys-plotting-module"></span><h2>pyodesys.plotting module<a class="headerlink" href="#module-pyodesys.plotting" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyodesys.plotting.info_vlines">
<code class="sig-prename descclassname">pyodesys.plotting.</code><code class="sig-name descname">info_vlines</code><span class="sig-paren">(</span><em class="sig-param">ax</em>, <em class="sig-param">xout</em>, <em class="sig-param">info</em>, <em class="sig-param">vline_colors=('maroon'</em>, <em class="sig-param">'purple')</em>, <em class="sig-param">vline_keys=('steps'</em>, <em class="sig-param">'rhs_xvals'</em>, <em class="sig-param">'jac_xvals')</em>, <em class="sig-param">post_proc=None</em>, <em class="sig-param">alpha=None</em>, <em class="sig-param">fpes=None</em>, <em class="sig-param">every=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/plotting.html#info_vlines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.plotting.info_vlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot vertical lines in the background</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">axes</span></dt><dd></dd>
<dt><strong>xout</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>info</strong><span class="classifier">dict</span></dt><dd></dd>
<dt><strong>vline_colors</strong><span class="classifier">iterable of str</span></dt><dd></dd>
<dt><strong>vline_keys</strong><span class="classifier">iterable of str</span></dt><dd><p>Choose from <code class="docutils literal notranslate"><span class="pre">'steps',</span> <span class="pre">'rhs_xvals',</span> <span class="pre">'jac_xvals',</span>
<span class="pre">'fe_underflow',</span> <span class="pre">'fe_overflow',</span> <span class="pre">'fe_invalid',</span> <span class="pre">'fe_divbyzero'</span></code>.</p>
</dd>
<dt><strong>vline_post_proc</strong><span class="classifier">callable</span></dt><dd></dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyodesys.plotting.plot_phase_plane">
<code class="sig-prename descclassname">pyodesys.plotting.</code><code class="sig-name descname">plot_phase_plane</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">plot=None</em>, <em class="sig-param">names=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/plotting.html#plot_phase_plane"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.plotting.plot_phase_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the phase portrait of two dependent variables</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: array_like</strong></dt><dd><p>Values of the independent variable.</p>
</dd>
<dt><strong>y: array_like</strong></dt><dd><p>Values of the dependent variables.</p>
</dd>
<dt><strong>indices: pair of integers (default: None)</strong></dt><dd><p>What dependent variable to plot for (None =&gt; (0, 1)).</p>
</dd>
<dt><strong>plot: callable (default: None)</strong></dt><dd><p>Uses <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot</span></code> if <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt><strong>names: iterable of strings</strong></dt><dd><p>Labels for x and y axis.</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Keyword arguemtns passed to <code class="docutils literal notranslate"><span class="pre">plot()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyodesys.plotting.plot_result">
<code class="sig-prename descclassname">pyodesys.plotting.</code><code class="sig-name descname">plot_result</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">plot_kwargs_cb=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">ls=('-'</em>, <em class="sig-param">'--'</em>, <em class="sig-param">':'</em>, <em class="sig-param">'-.')</em>, <em class="sig-param">c=('tab:blue'</em>, <em class="sig-param">'tab:orange'</em>, <em class="sig-param">'tab:green'</em>, <em class="sig-param">'tab:red'</em>, <em class="sig-param">'tab:purple'</em>, <em class="sig-param">'tab:brown'</em>, <em class="sig-param">'tab:pink'</em>, <em class="sig-param">'tab:gray'</em>, <em class="sig-param">'tab:olive'</em>, <em class="sig-param">'tab:cyan'</em>, <em class="sig-param">'black')</em>, <em class="sig-param">m=('o'</em>, <em class="sig-param">'v'</em>, <em class="sig-param">'8'</em>, <em class="sig-param">'s'</em>, <em class="sig-param">'p'</em>, <em class="sig-param">'x'</em>, <em class="sig-param">'+'</em>, <em class="sig-param">'d'</em>, <em class="sig-param">'s')</em>, <em class="sig-param">m_lim=-1</em>, <em class="sig-param">lines=None</em>, <em class="sig-param">interpolate=None</em>, <em class="sig-param">interp_from_deriv=None</em>, <em class="sig-param">names=None</em>, <em class="sig-param">latex_names=None</em>, <em class="sig-param">xlabel=None</em>, <em class="sig-param">ylabel=None</em>, <em class="sig-param">xscale=None</em>, <em class="sig-param">yscale=None</em>, <em class="sig-param">legend=False</em>, <em class="sig-param">yerr=None</em>, <em class="sig-param">labels=None</em>, <em class="sig-param">tex_lbl_fmt='$%s$'</em>, <em class="sig-param">fig_kw=None</em>, <em class="sig-param">xlim=None</em>, <em class="sig-param">ylim=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/plotting.html#plot_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.plotting.plot_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the depepndent variables vs. the independent variable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Values of the independent variable.</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>Values of the independent variable. This must hold
<code class="docutils literal notranslate"><span class="pre">y.shape[0]</span> <span class="pre">==</span> <span class="pre">len(x)</span></code>, plot_results will draw
<code class="docutils literal notranslate"><span class="pre">y.shape[1]</span></code> lines. If <code class="docutils literal notranslate"><span class="pre">interpolate</span> <span class="pre">!=</span> <span class="pre">None</span></code>
y is expected two be three dimensional, otherwise two dimensional.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">iterable of integers</span></dt><dd><p>What indices to plot (default: None =&gt; all).</p>
</dd>
<dt><strong>plot</strong><span class="classifier">callback (default: None)</span></dt><dd><p>If None, use <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot</span></code>.</p>
</dd>
<dt><strong>plot_kwargs_cb</strong><span class="classifier">callback(int) -&gt; dict</span></dt><dd><p>Keyword arguments for plot for each index (0:len(y)-1).</p>
</dd>
<dt><strong>ax</strong><span class="classifier">Axes</span></dt><dd></dd>
<dt><strong>ls</strong><span class="classifier">iterable</span></dt><dd><p>Linestyles to cycle through (only used if plot and plot_kwargs_cb
are both None).</p>
</dd>
<dt><strong>c</strong><span class="classifier">iterable</span></dt><dd><p>Colors to cycle through (only used if plot and plot_kwargs_cb
are both None).</p>
</dd>
<dt><strong>m</strong><span class="classifier">iterable</span></dt><dd><p>Markers to cycle through (only used if plot and plot_kwargs_cb
are both None and m_lim &gt; 0).</p>
</dd>
<dt><strong>m_lim</strong><span class="classifier">int (default: -1)</span></dt><dd><p>Upper limit (exclusive, number of points) for using markers instead of
lines.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">None</span></dt><dd><p>default: draw between markers unless we are interpolating as well.</p>
</dd>
<dt><strong>interpolate</strong><span class="classifier">bool or int (default: None)</span></dt><dd><p>Density-multiplier for grid of independent variable when interpolating
if True =&gt; 20. negative integer signifies log-spaced grid.</p>
</dd>
<dt><strong>interp_from_deriv</strong><span class="classifier">callback (default: None)</span></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">None</span></code>: <code class="docutils literal notranslate"><span class="pre">scipy.interpolate.BPoly.from_derivatives</span></code></p>
</dd>
<dt><strong>names</strong><span class="classifier">iterable of str</span></dt><dd></dd>
<dt><strong>latex_names</strong><span class="classifier">iterable of str</span></dt><dd></dd>
<dt><strong>labels</strong><span class="classifier">iterable of str</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, use <code class="docutils literal notranslate"><span class="pre">latex_names</span></code> or <code class="docutils literal notranslate"><span class="pre">names</span></code> (in that order).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyodesys.plotting.right_hand_ylabels">
<code class="sig-prename descclassname">pyodesys.plotting.</code><code class="sig-name descname">right_hand_ylabels</code><span class="sig-paren">(</span><em class="sig-param">ax</em>, <em class="sig-param">labels</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/plotting.html#right_hand_ylabels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.plotting.right_hand_ylabels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyodesys.results">
<span id="pyodesys-results-module"></span><h2>pyodesys.results module<a class="headerlink" href="#module-pyodesys.results" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyodesys.results.Result">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.results.</code><code class="sig-name descname">Result</code><span class="sig-paren">(</span><em class="sig-param">xout</em>, <em class="sig-param">yout</em>, <em class="sig-param">params</em>, <em class="sig-param">info</em>, <em class="sig-param">odesys</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.results.Result.at" title="pyodesys.results.Result.at"><code class="xref py py-obj docutils literal notranslate"><span class="pre">at</span></code></a>(self, x[, use_deriv, xdata, ydata, linear])</p></td>
<td><p>Returns interpolated result at a given time and an interpolation error-estimate</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.results.Result.between" title="pyodesys.results.Result.between"><code class="xref py py-obj docutils literal notranslate"><span class="pre">between</span></code></a>(self, lower, upper[, xdata, ydata])</p></td>
<td><p>Get results inside span for independent variable</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.results.Result.plot" title="pyodesys.results.Result.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a>(self[, info_vlines_kw, between, deriv, …])</p></td>
<td><p>Plots the integrated dependent variables from last integration.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.results.Result.plot_phase_plane" title="pyodesys.results.Result.plot_phase_plane"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_phase_plane</span></code></a>(self[, indices])</p></td>
<td><p>Plots a phase portrait from last integration.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.results.Result.stiffness" title="pyodesys.results.Result.stiffness"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stiffness</span></code></a>(self[, xyp, eigenvals_cb])</p></td>
<td><p>Running stiffness ratio from last integration.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>calc_invariant_violations</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>copy</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>extend_by_integration</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>named_dep</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>named_param</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>plot_invariant_violations</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyodesys.results.Result.at">
<code class="sig-name descname">at</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">use_deriv=False</em>, <em class="sig-param">xdata=None</em>, <em class="sig-param">ydata=None</em>, <em class="sig-param">linear=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result.at"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result.at" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns interpolated result at a given time and an interpolation error-estimate</p>
<p>By default interpolation is performed using cubic splines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like or float</span></dt><dd></dd>
<dt><strong>use_deriv</strong><span class="classifier">bool</span></dt><dd><p>Calculate derivatives at spline knots for enhanced accuracy.</p>
</dd>
<dt><strong>xdata</strong><span class="classifier">array</span></dt><dd></dd>
<dt><strong>ydata</strong><span class="classifier">array</span></dt><dd></dd>
<dt><strong>linear</strong><span class="classifier">bool</span></dt><dd><p>Will use (cheaper) linear interpolation. Useful when x is an array.
Error estimate will be <code class="docutils literal notranslate"><span class="pre">None</span></code> in this case.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>interpolated_y</strong><span class="classifier">array</span></dt><dd></dd>
<dt><strong>error_estim_y</strong><span class="classifier">array</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyodesys.results.Result.between">
<code class="sig-name descname">between</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">lower</em>, <em class="sig-param">upper</em>, <em class="sig-param">xdata=None</em>, <em class="sig-param">ydata=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result.between"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result.between" title="Permalink to this definition">¶</a></dt>
<dd><p>Get results inside span for independent variable</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.results.Result.calc_invariant_violations">
<code class="sig-name descname">calc_invariant_violations</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">xyp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result.calc_invariant_violations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result.calc_invariant_violations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.results.Result.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.results.Result.extend_by_integration">
<code class="sig-name descname">extend_by_integration</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">xend</em>, <em class="sig-param">params=None</em>, <em class="sig-param">odesys=None</em>, <em class="sig-param">autonomous=None</em>, <em class="sig-param">npoints=1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result.extend_by_integration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result.extend_by_integration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.results.Result.named_dep">
<code class="sig-name descname">named_dep</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result.named_dep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result.named_dep" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.results.Result.named_param">
<code class="sig-name descname">named_param</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">param_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result.named_param"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result.named_param" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.results.Result.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">info_vlines_kw=None</em>, <em class="sig-param">between=None</em>, <em class="sig-param">deriv=False</em>, <em class="sig-param">title_info=0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the integrated dependent variables from last integration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>info_vlines_kw</strong><span class="classifier">dict</span></dt><dd><p>Keyword arguments passed to <a class="reference internal" href="#pyodesys.plotting.info_vlines" title="pyodesys.plotting.info_vlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">plotting.info_vlines()</span></code></a>,
an empty dict will be used if <cite>True</cite>. Need to pass <cite>ax</cite> when given.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">iterable of int</span></dt><dd></dd>
<dt><strong>between</strong><span class="classifier">length 2 tuple</span></dt><dd></dd>
<dt><strong>deriv</strong><span class="classifier">bool</span></dt><dd><p>Plot derivatives (internal variables).</p>
</dd>
<dt><strong>names</strong><span class="classifier">iterable of str</span></dt><dd></dd>
<dt><strong>**kwargs:</strong></dt><dd><p>See <a class="reference internal" href="#pyodesys.plotting.plot_result" title="pyodesys.plotting.plot_result"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyodesys.plotting.plot_result()</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyodesys.results.Result.plot_invariant_violations">
<code class="sig-name descname">plot_invariant_violations</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result.plot_invariant_violations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result.plot_invariant_violations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.results.Result.plot_phase_plane">
<code class="sig-name descname">plot_phase_plane</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result.plot_phase_plane"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result.plot_phase_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a phase portrait from last integration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices</strong><span class="classifier">iterable of int</span></dt><dd></dd>
<dt><strong>names</strong><span class="classifier">iterable of str</span></dt><dd></dd>
<dt><strong>**kwargs:</strong></dt><dd><p>See <a class="reference internal" href="#pyodesys.plotting.plot_phase_plane" title="pyodesys.plotting.plot_phase_plane"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyodesys.plotting.plot_phase_plane()</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyodesys.results.Result.stiffness">
<code class="sig-name descname">stiffness</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">xyp=None</em>, <em class="sig-param">eigenvals_cb=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/results.html#Result.stiffness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.results.Result.stiffness" title="Permalink to this definition">¶</a></dt>
<dd><p>Running stiffness ratio from last integration.</p>
<p>Calculate sittness ratio, i.e. the ratio between the largest and
smallest absolute eigenvalue of the jacobian matrix. The user may
supply their own routine for calculating the eigenvalues, or they
will be calculated from the SVD (singular value decomposition).
Note that calculating the SVD for any but the smallest Jacobians may
prove to be prohibitively expensive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyp</strong><span class="classifier">length 3 tuple (default: None)</span></dt><dd><p>internal_xout, internal_yout, internal_params, taken
from last integration if not specified.</p>
</dd>
<dt><strong>eigenvals_cb</strong><span class="classifier">callback (optional)</span></dt><dd><p>Signature (x, y, p) (internal variables), when not provided an
internal routine will use <code class="docutils literal notranslate"><span class="pre">self.j_cb</span></code> and <code class="docutils literal notranslate"><span class="pre">scipy.linalg.svd</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyodesys.symbolic">
<span id="pyodesys-symbolic-module"></span><h2>pyodesys.symbolic module<a class="headerlink" href="#module-pyodesys.symbolic" title="Permalink to this headline">¶</a></h2>
<p>This module contains a subclass of ODESys which allows the user to generate
auxiliary expressions from a canonical set of symbolic expressions. Subclasses
are also provided for dealing with variable transformations and partially
solved systems.</p>
<dl class="class">
<dt id="pyodesys.symbolic.PartiallySolvedSystem">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.symbolic.</code><code class="sig-name descname">PartiallySolvedSystem</code><span class="sig-paren">(</span><em class="sig-param">original_system</em>, <em class="sig-param">analytic_factory</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#PartiallySolvedSystem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.PartiallySolvedSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyodesys.symbolic.SymbolicSys</span></code></a></p>
<p>Use analytic expressions for some dependent variables</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>original_system</strong><span class="classifier">SymbolicSys</span></dt><dd></dd>
<dt><strong>analytic_factory</strong><span class="classifier">callable</span></dt><dd><p>User provided callback for expressing analytic solutions to a set of
dependent variables in <code class="docutils literal notranslate"><span class="pre">original_system</span></code>. The callback should have
the signature: <code class="docutils literal notranslate"><span class="pre">my_factory(x0,</span> <span class="pre">y0,</span> <span class="pre">p0,</span> <span class="pre">backend)</span> <span class="pre">-&gt;</span> <span class="pre">dict</span></code>, where the returned
dictionary maps dependent variabels (from <code class="docutils literal notranslate"><span class="pre">original_system.dep</span></code>)
to new expressions in remaining variables and initial conditions.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Keyword arguments passed onto <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicSys</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">odesys</span> <span class="o">=</span> <span class="n">SymbolicSys</span><span class="o">.</span><span class="n">from_callback</span><span class="p">(</span>
<span class="gp">... </span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="p">[</span>
<span class="gp">... </span>        <span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>        <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dep0</span> <span class="o">=</span> <span class="n">odesys</span><span class="o">.</span><span class="n">dep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">partsys</span> <span class="o">=</span> <span class="n">PartiallySolvedSystem</span><span class="p">(</span><span class="n">odesys</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">be</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">... </span>        <span class="n">dep0</span><span class="p">:</span> <span class="n">y0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">be</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">odesys</span><span class="o">.</span><span class="n">indep</span><span class="o">-</span><span class="n">x0</span><span class="p">))</span>
<span class="gp">... </span>    <span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">partsys</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>  
<span class="go">(_Dummy_29*p_0*exp(-p_0*(-_Dummy_28 + x)) - p_1*y_1,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xout</span><span class="p">,</span> <span class="n">yout</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">partsys</span><span class="o">.</span><span class="n">integrate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="s1">&#39;scipy&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">],</span> <span class="n">yout</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">(True, 2)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>free_names</strong><span class="classifier">list of str</span></dt><dd></dd>
<dt><strong>analytic_exprs</strong><span class="classifier">list of expressions</span></dt><dd></dd>
<dt><strong>analytic_cb</strong><span class="classifier">callback</span></dt><dd></dd>
<dt><strong>original_dep</strong><span class="classifier">dependent variable of original system</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive</span></code>(self, y0, x0, xend[, params])</p></td>
<td><p>Integrate with integrator chosen output.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">analytic_stiffness</span></code>(self[, xyp])</p></td>
<td><p>Running stiffness ratio from last integration.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">chained_parameter_variation</span></code>(self, \*args, …)</p></td>
<td><p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">chained_parameter_variation()</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_callback</span></code>(rhs[, ny, nparams, …])</p></td>
<td><p>Create an instance from a callback.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.symbolic.PartiallySolvedSystem.from_linear_invariants" title="pyodesys.symbolic.PartiallySolvedSystem.from_linear_invariants"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_linear_invariants</span></code></a>(ori_sys[, preferred])</p></td>
<td><p>Reformulates the ODE system in fewer variables.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other</span></code>(ori, \*\*kwargs)</p></td>
<td><p>Creates a new instance with an existing one as a template.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other_new_params</span></code>(ori, par_subs, new_pars)</p></td>
<td><p>Creates a new instance with an existing one as a template (with new parameters)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other_new_params_by_name</span></code>(ori, par_subs)</p></td>
<td><p>Creates a new instance with an existing one as a template (with new parameters)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dfdx</span></code>(self)</p></td>
<td><p>Calculates 2nd derivatives of <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dfdx_callback</span></code>(self)</p></td>
<td><p>Generate a callback for evaluating derivative of <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_f_ty_callback</span></code>(self)</p></td>
<td><p>Generates a callback for evaluating <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_j_ty_callback</span></code>(self)</p></td>
<td><p>Generates a callback for evaluating the jacobian.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jac</span></code>(self)</p></td>
<td><p>Derives the jacobian from <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code> and <code class="docutils literal notranslate"><span class="pre">self.dep</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jtimes</span></code>(self)</p></td>
<td><p>Derive the jacobian-vector product from <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code> and <code class="docutils literal notranslate"><span class="pre">self.dep</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jtimes_callback</span></code>(self)</p></td>
<td><p>Generate a callback fro evaluating the jacobian-vector product.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_roots_callback</span></code>(self)</p></td>
<td><p>Generate a callback for evaluating <code class="docutils literal notranslate"><span class="pre">self.roots</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.symbolic.PartiallySolvedSystem.integrate" title="pyodesys.symbolic.PartiallySolvedSystem.integrate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate</span></code></a>(self, \*args, \*\*kwargs)</p></td>
<td><p>Integrate the system of ordinary differential equations.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jacobian_singular</span></code>(self)</p></td>
<td><p>Returns True if Jacobian is singular, else False.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_phase_plane</span></code>(self[, indices])</p></td>
<td><p>Plots a phase portrait from last integration.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_result</span></code>(self, \*\*kwargs)</p></td>
<td><p>Plots the integrated dependent variables from last integration.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">post_process</span></code>(self, xout, yout, params)</p></td>
<td><p>Transforms internal values to output, used internally.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pre_process</span></code>(self, xout, y0[, params])</p></td>
<td><p>Transforms input to internal values, used internally.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">predefined</span></code>(self, y0, xout[, params])</p></td>
<td><p>Integrate with user chosen output.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">stiffness</span></code>(self[, xyp, eigenvals_cb])</p></td>
<td><p>[DEPRECATED] Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.stiffness()</span></code>, stiffness ration</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 73%" />
<col style="width: 27%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>all_invariant_names</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>all_invariants</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>as_autonomous</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_first_step_callback</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_invariants_callback</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>to_arrays</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyodesys.symbolic.PartiallySolvedSystem.from_linear_invariants">
<em class="property">classmethod </em><code class="sig-name descname">from_linear_invariants</code><span class="sig-paren">(</span><em class="sig-param">ori_sys</em>, <em class="sig-param">preferred=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#PartiallySolvedSystem.from_linear_invariants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.PartiallySolvedSystem.from_linear_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Reformulates the ODE system in fewer variables.</p>
<p>Given linear invariant equations one can always reduce the number
of dependent variables in the system by the rank of the matrix describing
this linear system.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ori_sys</strong><span class="classifier"><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicSys</span></code></a> instance</span></dt><dd></dd>
<dt><strong>preferred</strong><span class="classifier">iterable of preferred dependent variables</span></dt><dd><p>Due to numerical rounding it is preferable to choose the variables
which are expected to be of the largest magnitude during integration.</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Keyword arguments passed on to constructor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.PartiallySolvedSystem.integrate">
<code class="sig-name descname">integrate</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#PartiallySolvedSystem.integrate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.PartiallySolvedSystem.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate the system of ordinary differential equations.</p>
<p>Solves the initial value problem (IVP).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like or pair (start and final time) or float</span></dt><dd><dl class="simple">
<dt>if float:</dt><dd><p>make it a pair: (0, x)</p>
</dd>
<dt>if pair or length-2 array:</dt><dd><p>initial and final value of the independent variable</p>
</dd>
<dt>if array_like:</dt><dd><p>values of independent variable report at</p>
</dd>
</dl>
</dd>
<dt><strong>y0</strong><span class="classifier">array_like</span></dt><dd><p>Initial values at x[0] for the dependent variables.</p>
</dd>
<dt><strong>params</strong><span class="classifier">array_like (default: tuple())</span></dt><dd><p>Value of parameters passed to user-supplied callbacks.</p>
</dd>
<dt><strong>integrator</strong><span class="classifier">str or None</span></dt><dd><dl class="simple">
<dt>Name of integrator, one of:</dt><dd><ul class="simple">
<li><p>‘scipy’: <code class="xref py py-meth docutils literal notranslate"><span class="pre">_integrate_scipy()</span></code></p></li>
<li><p>‘gsl’: <code class="xref py py-meth docutils literal notranslate"><span class="pre">_integrate_gsl()</span></code></p></li>
<li><p>‘odeint’: <code class="xref py py-meth docutils literal notranslate"><span class="pre">_integrate_odeint()</span></code></p></li>
<li><p>‘cvode’:  <code class="xref py py-meth docutils literal notranslate"><span class="pre">_integrate_cvode()</span></code></p></li>
</ul>
</dd>
</dl>
<p>See respective method for more information.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>: <code class="docutils literal notranslate"><span class="pre">os.environ.get('PYODESYS_INTEGRATOR',</span> <span class="pre">'scipy')</span></code></p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>Absolute tolerance</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float</span></dt><dd><p>Relative tolerance</p>
</dd>
<dt><strong>with_jacobian</strong><span class="classifier">bool or None (default)</span></dt><dd><p>Whether to use the jacobian. When <code class="docutils literal notranslate"><span class="pre">None</span></code> the choice is
done automatically (only used when required). This matters
when jacobian is derived at runtime (high computational cost).</p>
</dd>
<dt><strong>with_jtimes</strong><span class="classifier">bool (default: False)</span></dt><dd><p>Whether to use the jacobian-vector product. This is only supported
by <code class="docutils literal notranslate"><span class="pre">cvode</span></code> and only when <code class="docutils literal notranslate"><span class="pre">linear_solver</span></code> is one of: gmres’,
‘gmres_classic’, ‘bicgstab’, ‘tfqmr’. See the documentation
for <code class="docutils literal notranslate"><span class="pre">pycvodes</span></code> for more information.</p>
</dd>
<dt><strong>force_predefined</strong><span class="classifier">bool (default: False)</span></dt><dd><p>override behaviour of <code class="docutils literal notranslate"><span class="pre">len(x)</span> <span class="pre">==</span> <span class="pre">2</span></code> =&gt; <code class="xref py py-meth docutils literal notranslate"><span class="pre">adaptive()</span></code></p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Additional keyword arguments for <code class="docutils literal notranslate"><span class="pre">_integrate_$(integrator)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Length 3 tuple: (x, yout, info)</dt><dd><p>x : array of values of the independent variable
yout : array of the dependent variable(s) for the different</p>
<blockquote>
<div><p>values of x.</p>
</div></blockquote>
<p>info : dict (‘nfev’ is guaranteed to be a key)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyodesys.symbolic.ScaledSys">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.symbolic.</code><code class="sig-name descname">ScaledSys</code><span class="sig-paren">(</span><em class="sig-param">dep_exprs</em>, <em class="sig-param">indep=None</em>, <em class="sig-param">dep_scaling=1</em>, <em class="sig-param">indep_scaling=1</em>, <em class="sig-param">params=()</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#ScaledSys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.ScaledSys" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyodesys.symbolic.TransformedSys" title="pyodesys.symbolic.TransformedSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyodesys.symbolic.TransformedSys</span></code></a></p>
<p>Transformed system where the variables have been scaled linearly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dep_exprs</strong><span class="classifier">iterable of (symbol, expression)-pairs</span></dt><dd><p>see <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicSys</span></code></a></p>
</dd>
<dt><strong>indep</strong><span class="classifier">Symbol</span></dt><dd><p>see <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicSys</span></code></a></p>
</dd>
<dt><strong>dep_scaling</strong><span class="classifier">number (&gt;0) or iterable of numbers</span></dt><dd><p>scaling of the dependent variables (default: 1)</p>
</dd>
<dt><strong>indep_scaling</strong><span class="classifier">number (&gt;0)</span></dt><dd><p>scaling of the independent variable (default: 1)</p>
</dd>
<dt><strong>params :</strong></dt><dd><p>see <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicSys</span></code></a></p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Keyword arguments passed onto <a class="reference internal" href="#pyodesys.symbolic.TransformedSys" title="pyodesys.symbolic.TransformedSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformedSys</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaled1</span> <span class="o">=</span> <span class="n">ScaledSys</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)],</span> <span class="n">dep_scaling</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaled1</span><span class="o">.</span><span class="n">exprs</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">1000</span><span class="p">,)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaled2</span> <span class="o">=</span> <span class="n">ScaledSys</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)],</span> <span class="n">dep_scaling</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaled2</span><span class="o">.</span><span class="n">exprs</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">1000000</span><span class="p">,)</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>linear_invariants</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ny</span></code></dt><dd><p>Number of dependent variables in the system.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive</span></code>(self, y0, x0, xend[, params])</p></td>
<td><p>Integrate with integrator chosen output.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">analytic_stiffness</span></code>(self[, xyp])</p></td>
<td><p>Running stiffness ratio from last integration.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">chained_parameter_variation</span></code>(self, \*args, …)</p></td>
<td><p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">chained_parameter_variation()</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.symbolic.ScaledSys.from_callback" title="pyodesys.symbolic.ScaledSys.from_callback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_callback</span></code></a>(cb[, ny, nparams, …])</p></td>
<td><p>Create an instance from a callback.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other</span></code>(ori, \*\*kwargs)</p></td>
<td><p>Creates a new instance with an existing one as a template.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other_new_params</span></code>(ori, par_subs, new_pars)</p></td>
<td><p>Creates a new instance with an existing one as a template (with new parameters)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other_new_params_by_name</span></code>(ori, par_subs)</p></td>
<td><p>Creates a new instance with an existing one as a template (with new parameters)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dfdx</span></code>(self)</p></td>
<td><p>Calculates 2nd derivatives of <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dfdx_callback</span></code>(self)</p></td>
<td><p>Generate a callback for evaluating derivative of <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_f_ty_callback</span></code>(self)</p></td>
<td><p>Generates a callback for evaluating <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_j_ty_callback</span></code>(self)</p></td>
<td><p>Generates a callback for evaluating the jacobian.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jac</span></code>(self)</p></td>
<td><p>Derives the jacobian from <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code> and <code class="docutils literal notranslate"><span class="pre">self.dep</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jtimes</span></code>(self)</p></td>
<td><p>Derive the jacobian-vector product from <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code> and <code class="docutils literal notranslate"><span class="pre">self.dep</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jtimes_callback</span></code>(self)</p></td>
<td><p>Generate a callback fro evaluating the jacobian-vector product.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_roots_callback</span></code>(self)</p></td>
<td><p>Generate a callback for evaluating <code class="docutils literal notranslate"><span class="pre">self.roots</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate</span></code>(self, x, y0[, params, atol, rtol])</p></td>
<td><p>Integrate the system of ordinary differential equations.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jacobian_singular</span></code>(self)</p></td>
<td><p>Returns True if Jacobian is singular, else False.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_phase_plane</span></code>(self[, indices])</p></td>
<td><p>Plots a phase portrait from last integration.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_result</span></code>(self, \*\*kwargs)</p></td>
<td><p>Plots the integrated dependent variables from last integration.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">post_process</span></code>(self, xout, yout, params)</p></td>
<td><p>Transforms internal values to output, used internally.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pre_process</span></code>(self, xout, y0[, params])</p></td>
<td><p>Transforms input to internal values, used internally.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">predefined</span></code>(self, y0, xout[, params])</p></td>
<td><p>Integrate with user chosen output.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">stiffness</span></code>(self[, xyp, eigenvals_cb])</p></td>
<td><p>[DEPRECATED] Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.stiffness()</span></code>, stiffness ration</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 73%" />
<col style="width: 27%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>all_invariant_names</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>all_invariants</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>as_autonomous</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_first_step_callback</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_invariants_callback</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>to_arrays</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyodesys.symbolic.ScaledSys.from_callback">
<em class="property">classmethod </em><code class="sig-name descname">from_callback</code><span class="sig-paren">(</span><em class="sig-param">cb</em>, <em class="sig-param">ny=None</em>, <em class="sig-param">nparams=None</em>, <em class="sig-param">dep_scaling=1</em>, <em class="sig-param">indep_scaling=1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#ScaledSys.from_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.ScaledSys.from_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instance from a callback.</p>
<p>Analogous to <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.from_callback" title="pyodesys.symbolic.SymbolicSys.from_callback"><code class="xref py py-func docutils literal notranslate"><span class="pre">SymbolicSys.from_callback()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cb</strong><span class="classifier">callable</span></dt><dd><p>Signature rhs(x, y[:], p[:]) -&gt; f[:]</p>
</dd>
<dt><strong>ny</strong><span class="classifier">int</span></dt><dd><p>length of y</p>
</dd>
<dt><strong>nparams</strong><span class="classifier">int</span></dt><dd><p>length of p</p>
</dd>
<dt><strong>dep_scaling</strong><span class="classifier">number (&gt;0) or iterable of numbers</span></dt><dd><p>scaling of the dependent variables (default: 1)</p>
</dd>
<dt><strong>indep_scaling: number (&gt;0)</strong></dt><dd><p>scaling of the independent variable (default: 1)</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Keyword arguments passed onto <a class="reference internal" href="#pyodesys.symbolic.ScaledSys" title="pyodesys.symbolic.ScaledSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScaledSys</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odesys</span> <span class="o">=</span> <span class="n">ScaledSys</span><span class="o">.</span><span class="n">from_callback</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dep_scaling</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odesys</span><span class="o">.</span><span class="n">exprs</span>
<span class="go">(p_0*y_0**2/10,)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyodesys.symbolic.SymbolicSys">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.symbolic.</code><code class="sig-name descname">SymbolicSys</code><span class="sig-paren">(</span><em class="sig-param">dep_exprs</em>, <em class="sig-param">indep=None</em>, <em class="sig-param">params=None</em>, <em class="sig-param">jac=True</em>, <em class="sig-param">dfdx=True</em>, <em class="sig-param">jtimes=False</em>, <em class="sig-param">first_step_expr=None</em>, <em class="sig-param">roots=None</em>, <em class="sig-param">backend=None</em>, <em class="sig-param">lower_bounds=None</em>, <em class="sig-param">upper_bounds=None</em>, <em class="sig-param">linear_invariants=None</em>, <em class="sig-param">nonlinear_invariants=None</em>, <em class="sig-param">linear_invariant_names=None</em>, <em class="sig-param">nonlinear_invariant_names=None</em>, <em class="sig-param">steady_state_root=False</em>, <em class="sig-param">init_indep=None</em>, <em class="sig-param">init_dep=None</em>, <em class="sig-param">sparse=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyodesys.core.ODESys" title="pyodesys.core.ODESys"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyodesys.core.ODESys</span></code></a></p>
<p>ODE System from symbolic expressions</p>
<p>Creates a <code class="xref py py-class docutils literal notranslate"><span class="pre">ODESys</span></code> instance
from symbolic expressions. Jacobian and second derivatives
are derived when needed.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>dep_exprs</strong><span class="classifier">iterable of (symbol, expression)-pairs</span></dt><dd></dd>
<dt><strong>indep</strong><span class="classifier">Symbol</span></dt><dd><p>Independent variable (default: None =&gt; autonomous system).</p>
</dd>
<dt><strong>params</strong><span class="classifier">iterable of symbols</span></dt><dd><p>Problem parameters. If <code class="docutils literal notranslate"><span class="pre">None</span></code>: zero parameters assumed (violation of this will
raise a ValueError), If <code class="docutils literal notranslate"><span class="pre">True</span></code>: params are deduced from (sorted) free_symbols.</p>
</dd>
<dt><strong>jac</strong><span class="classifier">ImmutableMatrix or bool (default: True)</span></dt><dd><dl class="simple">
<dt>if True:</dt><dd><p>calculate jacobian from exprs</p>
</dd>
<dt>if False:</dt><dd><p>do not compute jacobian (use explicit steppers)</p>
</dd>
<dt>if instance of ImmutableMatrix:</dt><dd><p>user provided expressions for the jacobian</p>
</dd>
</dl>
</dd>
<dt><strong>jtimes</strong><span class="classifier">bool or iterable of (symbol, expression)-pairs</span></dt><dd><dl class="simple">
<dt>if True:</dt><dd><p>calculate jacobian-vector product from exprs</p>
</dd>
<dt>if False:</dt><dd><p>do not compute jacobian-vector product</p>
</dd>
<dt>if instance of iterable of (symbol, expression) pairs:</dt><dd><p>user-provided expressions for the jacobian-vector product, where the symbols
are the elements of the vector being multiplied. Other than these symbols,
the expressions should only involve the symbols in :attr`dep` and
:attr`params`.</p>
</dd>
</dl>
</dd>
<dt><strong>dfdx</strong><span class="classifier">iterable of expressions</span></dt><dd><p>Derivatives of <code class="xref py py-attr docutils literal notranslate"><span class="pre">exprs</span></code> with respect to :attr`indep`.</p>
</dd>
<dt><strong>first_step_expr</strong><span class="classifier">expression</span></dt><dd><p>Closed form expression for calculating the first step. Be sure to pass
<code class="docutils literal notranslate"><span class="pre">first_step==0</span></code> to enable its use during integration. If not given,
the solver default behavior will be invoked.</p>
</dd>
<dt><strong>roots</strong><span class="classifier">iterable of expressions</span></dt><dd><p>Equations to look for root’s for during integration
(currently available through cvode).</p>
</dd>
<dt><strong>backend</strong><span class="classifier">str or sym.Backend</span></dt><dd><p>See documentation of <a class="reference external" href="http://bjodah.github.io/sym/latest/sym.html#module-sym.backend">sym.Backend</a>.</p>
</dd>
<dt><strong>lower_bounds</strong><span class="classifier">array_like</span></dt><dd><p>Convenience option setting magnitude constraint. (requires integrator with
support for recoverable errors)</p>
</dd>
<dt><strong>upper_bounds</strong><span class="classifier">array_like</span></dt><dd><p>Convenience option setting magnitude constraint. (requires integrator with
support for recoverable errors)</p>
</dd>
<dt><strong>linear_invariants</strong><span class="classifier">Matrix</span></dt><dd><p>Matrix specifing linear combinations of dependent variables that</p>
</dd>
<dt><strong>nonlinear_invariants</strong><span class="classifier">iterable of expressions</span></dt><dd><p>Iterable collection of expressions of nonlinear invariants.</p>
</dd>
<dt><strong>steady_state_root</strong><span class="classifier">bool or float</span></dt><dd><p>Generate an expressions for roots which is the sum the smaller of
aboslute values of derivatives or relative derivatives subtracted by
the value of <code class="docutils literal notranslate"><span class="pre">steady_state_root</span></code> (default <code class="docutils literal notranslate"><span class="pre">1e-10</span></code>).</p>
</dd>
<dt><strong>init_indep</strong><span class="classifier">Symbol,  <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">True</span></code> construct using <code class="docutils literal notranslate"><span class="pre">be.Symbol</span></code>. See also <code class="xref py py-attr docutils literal notranslate"><span class="pre">init_indep</span></code>.</p>
</dd>
<dt><strong>init_dep</strong><span class="classifier">tuple of Symbols, <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">True</span></code> construct using <code class="docutils literal notranslate"><span class="pre">be.Symbol</span></code>. See also <code class="xref py py-attr docutils literal notranslate"><span class="pre">init_dep</span></code>.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)</span></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">True</span></code>, jacobian will be derived and stored (if <code class="docutils literal notranslate"><span class="pre">jac</span> <span class="pre">=</span> <span class="pre">True</span></code>)
in compressed sparse column (CSC) format and the jacobian callback
will return an instance of <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csc_matrix</span></code>.</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">ODESys</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>dep</strong><span class="classifier">tuple of symbols</span></dt><dd><p>Dependent variables.</p>
</dd>
<dt><strong>exprs</strong><span class="classifier">tuple of expressions</span></dt><dd><p>Expressions for the derivatives of the dependent variables
(<code class="xref py py-attr docutils literal notranslate"><span class="pre">dep</span></code>) with respect to the independent variable (<code class="xref py py-attr docutils literal notranslate"><span class="pre">indep</span></code>).</p>
</dd>
<dt><strong>indep</strong><span class="classifier">Symbol or None</span></dt><dd><p>Independent variable (<code class="docutils literal notranslate"><span class="pre">None</span></code> indicates autonomous system).</p>
</dd>
<dt><strong>params</strong><span class="classifier">iterable of symbols</span></dt><dd><p>Problem parameters.</p>
</dd>
<dt><strong>first_step_expr</strong><span class="classifier">expression</span></dt><dd><p>Closed form expression for how to compute the first step.</p>
</dd>
<dt><strong>roots</strong><span class="classifier">iterable of expressions or None</span></dt><dd><p>Roots to report for during integration.</p>
</dd>
<dt><strong>backend</strong><span class="classifier">module</span></dt><dd><p>Symbolic backend, e.g. ‘sympy’, ‘symengine’.</p>
</dd>
<dt><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.ny" title="pyodesys.symbolic.SymbolicSys.ny"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ny</span></code></a><span class="classifier">int</span></dt><dd><p>Number of dependent variables in the system.</p>
</dd>
<dt><strong>init_indep</strong><span class="classifier">Symbol,  <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Symbol for initial value of independent variable (before pre processors).</p>
</dd>
<dt><strong>init_dep</strong><span class="classifier">tuple of Symbols or <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Symbols for initial values of dependent variables (before pre processors).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive</span></code>(self, y0, x0, xend[, params])</p></td>
<td><p>Integrate with integrator chosen output.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.analytic_stiffness" title="pyodesys.symbolic.SymbolicSys.analytic_stiffness"><code class="xref py py-obj docutils literal notranslate"><span class="pre">analytic_stiffness</span></code></a>(self[, xyp])</p></td>
<td><p>Running stiffness ratio from last integration.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">chained_parameter_variation</span></code>(self, \*args, …)</p></td>
<td><p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">chained_parameter_variation()</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.from_callback" title="pyodesys.symbolic.SymbolicSys.from_callback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_callback</span></code></a>(rhs[, ny, nparams, …])</p></td>
<td><p>Create an instance from a callback.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.from_other" title="pyodesys.symbolic.SymbolicSys.from_other"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other</span></code></a>(ori, \*\*kwargs)</p></td>
<td><p>Creates a new instance with an existing one as a template.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.from_other_new_params" title="pyodesys.symbolic.SymbolicSys.from_other_new_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other_new_params</span></code></a>(ori, par_subs, new_pars)</p></td>
<td><p>Creates a new instance with an existing one as a template (with new parameters)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.from_other_new_params_by_name" title="pyodesys.symbolic.SymbolicSys.from_other_new_params_by_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other_new_params_by_name</span></code></a>(ori, par_subs)</p></td>
<td><p>Creates a new instance with an existing one as a template (with new parameters)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.get_dfdx" title="pyodesys.symbolic.SymbolicSys.get_dfdx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dfdx</span></code></a>(self)</p></td>
<td><p>Calculates 2nd derivatives of <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.get_dfdx_callback" title="pyodesys.symbolic.SymbolicSys.get_dfdx_callback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dfdx_callback</span></code></a>(self)</p></td>
<td><p>Generate a callback for evaluating derivative of <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.get_f_ty_callback" title="pyodesys.symbolic.SymbolicSys.get_f_ty_callback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_f_ty_callback</span></code></a>(self)</p></td>
<td><p>Generates a callback for evaluating <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.get_j_ty_callback" title="pyodesys.symbolic.SymbolicSys.get_j_ty_callback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_j_ty_callback</span></code></a>(self)</p></td>
<td><p>Generates a callback for evaluating the jacobian.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.get_jac" title="pyodesys.symbolic.SymbolicSys.get_jac"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jac</span></code></a>(self)</p></td>
<td><p>Derives the jacobian from <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code> and <code class="docutils literal notranslate"><span class="pre">self.dep</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.get_jtimes" title="pyodesys.symbolic.SymbolicSys.get_jtimes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jtimes</span></code></a>(self)</p></td>
<td><p>Derive the jacobian-vector product from <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code> and <code class="docutils literal notranslate"><span class="pre">self.dep</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.get_jtimes_callback" title="pyodesys.symbolic.SymbolicSys.get_jtimes_callback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jtimes_callback</span></code></a>(self)</p></td>
<td><p>Generate a callback fro evaluating the jacobian-vector product.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.get_roots_callback" title="pyodesys.symbolic.SymbolicSys.get_roots_callback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_roots_callback</span></code></a>(self)</p></td>
<td><p>Generate a callback for evaluating <code class="docutils literal notranslate"><span class="pre">self.roots</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate</span></code>(self, x, y0[, params, atol, rtol])</p></td>
<td><p>Integrate the system of ordinary differential equations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.jacobian_singular" title="pyodesys.symbolic.SymbolicSys.jacobian_singular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">jacobian_singular</span></code></a>(self)</p></td>
<td><p>Returns True if Jacobian is singular, else False.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_phase_plane</span></code>(self[, indices])</p></td>
<td><p>Plots a phase portrait from last integration.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_result</span></code>(self, \*\*kwargs)</p></td>
<td><p>Plots the integrated dependent variables from last integration.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">post_process</span></code>(self, xout, yout, params)</p></td>
<td><p>Transforms internal values to output, used internally.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pre_process</span></code>(self, xout, y0[, params])</p></td>
<td><p>Transforms input to internal values, used internally.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">predefined</span></code>(self, y0, xout[, params])</p></td>
<td><p>Integrate with user chosen output.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">stiffness</span></code>(self[, xyp, eigenvals_cb])</p></td>
<td><p>[DEPRECATED] Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.stiffness()</span></code>, stiffness ration</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 73%" />
<col style="width: 27%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>all_invariant_names</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>all_invariants</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>as_autonomous</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_first_step_callback</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_invariants_callback</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>to_arrays</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.all_invariant_names">
<code class="sig-name descname">all_invariant_names</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.all_invariant_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.all_invariant_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.all_invariants">
<code class="sig-name descname">all_invariants</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">linear_invariants=None</em>, <em class="sig-param">nonlinear_invariants=None</em>, <em class="sig-param">dep=None</em>, <em class="sig-param">backend=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.all_invariants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.all_invariants" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.analytic_stiffness">
<code class="sig-name descname">analytic_stiffness</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">xyp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.analytic_stiffness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.analytic_stiffness" title="Permalink to this definition">¶</a></dt>
<dd><p>Running stiffness ratio from last integration.</p>
<p>Calculate sittness ratio, i.e. the ratio between the largest and
smallest absolute eigenvalue of the (analytic) jacobian matrix.</p>
<p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">ODESys.stiffness()</span></code> for more info.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyodesys.symbolic.SymbolicSys.append_iv">
<code class="sig-name descname">append_iv</code><em class="property"> = True</em><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.append_iv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.as_autonomous">
<code class="sig-name descname">as_autonomous</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">new_indep_name=None</em>, <em class="sig-param">new_latex_indep_name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.as_autonomous"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.as_autonomous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.from_callback">
<em class="property">classmethod </em><code class="sig-name descname">from_callback</code><span class="sig-paren">(</span><em class="sig-param">rhs</em>, <em class="sig-param">ny=None</em>, <em class="sig-param">nparams=None</em>, <em class="sig-param">first_step_factory=None</em>, <em class="sig-param">roots_cb=None</em>, <em class="sig-param">indep_name=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.from_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.from_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instance from a callback.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rhs</strong><span class="classifier">callbable</span></dt><dd><p>Signature <code class="docutils literal notranslate"><span class="pre">rhs(x,</span> <span class="pre">y[:],</span> <span class="pre">p[:],</span> <span class="pre">backend=math)</span> <span class="pre">-&gt;</span> <span class="pre">f[:]</span></code>.</p>
</dd>
<dt><strong>ny</strong><span class="classifier">int</span></dt><dd><p>Length of <code class="docutils literal notranslate"><span class="pre">y</span></code> in <code class="docutils literal notranslate"><span class="pre">rhs</span></code>.</p>
</dd>
<dt><strong>nparams</strong><span class="classifier">int</span></dt><dd><p>Length of <code class="docutils literal notranslate"><span class="pre">p</span></code> in <code class="docutils literal notranslate"><span class="pre">rhs</span></code>.</p>
</dd>
<dt><strong>first_step_factory</strong><span class="classifier">callabble</span></dt><dd><p>Signature <code class="docutils literal notranslate"><span class="pre">step1st(x,</span> <span class="pre">y[:],</span> <span class="pre">p[:])</span> <span class="pre">-&gt;</span> <span class="pre">dx0</span></code>.</p>
</dd>
<dt><strong>roots_cb</strong><span class="classifier">callable</span></dt><dd><p>Callback with signature <code class="docutils literal notranslate"><span class="pre">roots(x,</span> <span class="pre">y[:],</span> <span class="pre">p[:],</span> <span class="pre">backend=math)</span> <span class="pre">-&gt;</span> <span class="pre">r[:]</span></code>.</p>
</dd>
<dt><strong>indep_name</strong><span class="classifier">str</span></dt><dd><p>Default ‘x’ if not already in <code class="docutils literal notranslate"><span class="pre">names</span></code>, otherwise indep0, or indep1, or …</p>
</dd>
<dt><strong>dep_by_name</strong><span class="classifier">bool</span></dt><dd><p>Make <code class="docutils literal notranslate"><span class="pre">y</span></code> passed to <code class="docutils literal notranslate"><span class="pre">rhs</span></code> a dict (keys from <code class="xref py py-attr docutils literal notranslate"><span class="pre">names</span></code>) and convert
its return value from dict to array.</p>
</dd>
<dt><strong>par_by_name</strong><span class="classifier">bool</span></dt><dd><p>Make <code class="docutils literal notranslate"><span class="pre">p</span></code> passed to <code class="docutils literal notranslate"><span class="pre">rhs</span></code> a dict (keys from <code class="xref py py-attr docutils literal notranslate"><span class="pre">param_names</span></code>).</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Keyword arguments passed onto <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicSys</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>An instance of <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicSys</span></code></a>.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">decay</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">rate</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="s1">&#39;Po-210&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;Po-210&#39;</span><span class="p">:</span> <span class="o">-</span><span class="n">rate</span><span class="p">,</span> <span class="s1">&#39;Pb-206&#39;</span><span class="p">:</span> <span class="n">rate</span><span class="p">}</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odesys</span> <span class="o">=</span> <span class="n">SymbolicSys</span><span class="o">.</span><span class="n">from_callback</span><span class="p">(</span><span class="n">decay</span><span class="p">,</span> <span class="n">dep_by_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Po-210&#39;</span><span class="p">,</span> <span class="s1">&#39;Pb-206&#39;</span><span class="p">),</span> <span class="n">nparams</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xout</span><span class="p">,</span> <span class="n">yout</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">odesys</span><span class="o">.</span><span class="n">integrate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">138.4</span><span class="o">*</span><span class="mi">24</span><span class="o">*</span><span class="mi">3600</span><span class="p">],</span> <span class="p">{</span><span class="s1">&#39;Po-210&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;Pb-206&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">},</span> <span class="p">[</span><span class="mf">5.798e-8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span><span class="p">;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">yout</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.from_other">
<em class="property">classmethod </em><code class="sig-name descname">from_other</code><span class="sig-paren">(</span><em class="sig-param">ori</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.from_other"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.from_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new instance with an existing one as a template.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ori</strong><span class="classifier">SymbolicSys instance</span></dt><dd></dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Keyword arguments used to create the new instance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new instance of the class.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.from_other_new_params">
<em class="property">classmethod </em><code class="sig-name descname">from_other_new_params</code><span class="sig-paren">(</span><em class="sig-param">ori</em>, <em class="sig-param">par_subs</em>, <em class="sig-param">new_pars</em>, <em class="sig-param">new_par_names=None</em>, <em class="sig-param">new_latex_par_names=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.from_other_new_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.from_other_new_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new instance with an existing one as a template (with new parameters)</p>
<p>Calls <code class="docutils literal notranslate"><span class="pre">.from_other</span></code> but first it replaces some parameters according to <code class="docutils literal notranslate"><span class="pre">par_subs</span></code>
and (optionally) introduces new parameters given in <code class="docutils literal notranslate"><span class="pre">new_pars</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ori</strong><span class="classifier">SymbolicSys instance</span></dt><dd></dd>
<dt><strong>par_subs</strong><span class="classifier">dict</span></dt><dd><p>Dictionary with substitutions (mapping symbols to new expressions) for parameters.
Parameters appearing in this instance will be omitted in the new instance.</p>
</dd>
<dt><strong>new_pars</strong><span class="classifier">iterable (optional)</span></dt><dd><p>Iterable of symbols for new parameters.</p>
</dd>
<dt><strong>new_par_names</strong><span class="classifier">iterable of str</span></dt><dd><p>Names of the new parameters given in <code class="docutils literal notranslate"><span class="pre">new_pars</span></code>.</p>
</dd>
<dt><strong>new_latex_par_names</strong><span class="classifier">iterable of str</span></dt><dd><p>TeX formatted names of the new parameters given in <code class="docutils literal notranslate"><span class="pre">new_pars</span></code>.</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Keyword arguments passed to <code class="docutils literal notranslate"><span class="pre">.from_other</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Intance of the class</dt><dd></dd>
<dt><strong>extra</strong><span class="classifier">dict with keys:</span></dt><dd><ul class="simple">
<li><p>recalc_params : <code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">y,</span> <span class="pre">p1)</span> <span class="pre">-&gt;</span> <span class="pre">p0</span></code></p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.from_other_new_params_by_name">
<em class="property">classmethod </em><code class="sig-name descname">from_other_new_params_by_name</code><span class="sig-paren">(</span><em class="sig-param">ori</em>, <em class="sig-param">par_subs</em>, <em class="sig-param">new_par_names=()</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.from_other_new_params_by_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.from_other_new_params_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new instance with an existing one as a template (with new parameters)</p>
<p>Calls <code class="docutils literal notranslate"><span class="pre">.from_other_new_params</span></code> but first it creates the new instances from user provided
callbacks generating the expressions the parameter substitutions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ori</strong><span class="classifier">SymbolicSys instance</span></dt><dd></dd>
<dt><strong>par_subs</strong><span class="classifier">dict mapping str to <code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">y{},</span> <span class="pre">p{})</span> <span class="pre">-&gt;</span> <span class="pre">expr</span></code></span></dt><dd><p>User provided callbacks for parameter names in <code class="docutils literal notranslate"><span class="pre">ori</span></code>.</p>
</dd>
<dt><strong>new_par_names</strong><span class="classifier">iterable of str</span></dt><dd></dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Keyword arguments passed to <code class="docutils literal notranslate"><span class="pre">.from_other_new_params</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.get_dfdx">
<code class="sig-name descname">get_dfdx</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.get_dfdx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.get_dfdx" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates 2nd derivatives of <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.get_dfdx_callback">
<code class="sig-name descname">get_dfdx_callback</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.get_dfdx_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.get_dfdx_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a callback for evaluating derivative of <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.get_f_ty_callback">
<code class="sig-name descname">get_f_ty_callback</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.get_f_ty_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.get_f_ty_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a callback for evaluating <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.get_first_step_callback">
<code class="sig-name descname">get_first_step_callback</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.get_first_step_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.get_first_step_callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.get_invariants_callback">
<code class="sig-name descname">get_invariants_callback</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.get_invariants_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.get_invariants_callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.get_j_ty_callback">
<code class="sig-name descname">get_j_ty_callback</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.get_j_ty_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.get_j_ty_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a callback for evaluating the jacobian.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.get_jac">
<code class="sig-name descname">get_jac</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.get_jac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.get_jac" title="Permalink to this definition">¶</a></dt>
<dd><p>Derives the jacobian from <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code> and <code class="docutils literal notranslate"><span class="pre">self.dep</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.get_jtimes">
<code class="sig-name descname">get_jtimes</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.get_jtimes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.get_jtimes" title="Permalink to this definition">¶</a></dt>
<dd><p>Derive the jacobian-vector product from <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code> and <code class="docutils literal notranslate"><span class="pre">self.dep</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.get_jtimes_callback">
<code class="sig-name descname">get_jtimes_callback</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.get_jtimes_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.get_jtimes_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a callback fro evaluating the jacobian-vector product.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.get_roots_callback">
<code class="sig-name descname">get_roots_callback</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.get_roots_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.get_roots_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a callback for evaluating <code class="docutils literal notranslate"><span class="pre">self.roots</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.jacobian_singular">
<code class="sig-name descname">jacobian_singular</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.jacobian_singular"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.jacobian_singular" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if Jacobian is singular, else False.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.linear_invariants">
<em class="property">property </em><code class="sig-name descname">linear_invariants</code><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.linear_invariants" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.ny">
<em class="property">property </em><code class="sig-name descname">ny</code><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.ny" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of dependent variables in the system.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.symbolic.SymbolicSys.to_arrays">
<code class="sig-name descname">to_arrays</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">p</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#SymbolicSys.to_arrays"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.SymbolicSys.to_arrays" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyodesys.symbolic.TransformedSys">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.symbolic.</code><code class="sig-name descname">TransformedSys</code><span class="sig-paren">(</span><em class="sig-param">dep_exprs</em>, <em class="sig-param">indep=None</em>, <em class="sig-param">dep_transf=None</em>, <em class="sig-param">indep_transf=None</em>, <em class="sig-param">params=()</em>, <em class="sig-param">exprs_process_cb=None</em>, <em class="sig-param">check_transforms=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#TransformedSys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.TransformedSys" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyodesys.symbolic.SymbolicSys</span></code></a></p>
<p>SymbolicSys with variable transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dep_exprs</strong><span class="classifier">iterable of pairs</span></dt><dd><p>see <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicSys</span></code></a></p>
</dd>
<dt><strong>indep</strong><span class="classifier">Symbol</span></dt><dd><p>see <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicSys</span></code></a></p>
</dd>
<dt><strong>dep_transf</strong><span class="classifier">iterable of (expression, expression) pairs</span></dt><dd><p>pairs of (forward, backward) transformations for the dependents
variables</p>
</dd>
<dt><strong>indep_transf</strong><span class="classifier">pair of expressions</span></dt><dd><p>forward and backward transformation of the independent variable</p>
</dd>
<dt><strong>params :</strong></dt><dd><p>see <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicSys</span></code></a></p>
</dd>
<dt><strong>exprs_process_cb</strong><span class="classifier">callbable</span></dt><dd><p>Post processing of the expressions (signature: <code class="docutils literal notranslate"><span class="pre">f(exprs)</span> <span class="pre">-&gt;</span> <span class="pre">exprs</span></code>)
for the derivatives of the dependent variables after transformation
have been applied.</p>
</dd>
<dt><strong>check_transforms</strong><span class="classifier">bool</span></dt><dd><p>Passed as keyword argument <code class="docutils literal notranslate"><span class="pre">check</span></code> to <a class="reference internal" href="#pyodesys.util.transform_exprs_dep" title="pyodesys.util.transform_exprs_dep"><code class="xref py py-func docutils literal notranslate"><span class="pre">util.transform_exprs_dep()</span></code></a> and
<a class="reference internal" href="#pyodesys.util.transform_exprs_indep" title="pyodesys.util.transform_exprs_indep"><code class="xref py py-func docutils literal notranslate"><span class="pre">util.transform_exprs_indep()</span></code></a>.</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Keyword arguments passed onto <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys" title="pyodesys.symbolic.SymbolicSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicSys</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>linear_invariants</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ny</span></code></dt><dd><p>Number of dependent variables in the system.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive</span></code>(self, y0, x0, xend[, params])</p></td>
<td><p>Integrate with integrator chosen output.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">analytic_stiffness</span></code>(self[, xyp])</p></td>
<td><p>Running stiffness ratio from last integration.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">chained_parameter_variation</span></code>(self, \*args, …)</p></td>
<td><p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">chained_parameter_variation()</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.symbolic.TransformedSys.from_callback" title="pyodesys.symbolic.TransformedSys.from_callback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_callback</span></code></a>(cb[, ny, nparams, …])</p></td>
<td><p>Create an instance from a callback.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other</span></code>(ori, \*\*kwargs)</p></td>
<td><p>Creates a new instance with an existing one as a template.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other_new_params</span></code>(ori, par_subs, new_pars)</p></td>
<td><p>Creates a new instance with an existing one as a template (with new parameters)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_other_new_params_by_name</span></code>(ori, par_subs)</p></td>
<td><p>Creates a new instance with an existing one as a template (with new parameters)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dfdx</span></code>(self)</p></td>
<td><p>Calculates 2nd derivatives of <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dfdx_callback</span></code>(self)</p></td>
<td><p>Generate a callback for evaluating derivative of <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_f_ty_callback</span></code>(self)</p></td>
<td><p>Generates a callback for evaluating <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_j_ty_callback</span></code>(self)</p></td>
<td><p>Generates a callback for evaluating the jacobian.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jac</span></code>(self)</p></td>
<td><p>Derives the jacobian from <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code> and <code class="docutils literal notranslate"><span class="pre">self.dep</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jtimes</span></code>(self)</p></td>
<td><p>Derive the jacobian-vector product from <code class="docutils literal notranslate"><span class="pre">self.exprs</span></code> and <code class="docutils literal notranslate"><span class="pre">self.dep</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_jtimes_callback</span></code>(self)</p></td>
<td><p>Generate a callback fro evaluating the jacobian-vector product.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_roots_callback</span></code>(self)</p></td>
<td><p>Generate a callback for evaluating <code class="docutils literal notranslate"><span class="pre">self.roots</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate</span></code>(self, x, y0[, params, atol, rtol])</p></td>
<td><p>Integrate the system of ordinary differential equations.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jacobian_singular</span></code>(self)</p></td>
<td><p>Returns True if Jacobian is singular, else False.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_phase_plane</span></code>(self[, indices])</p></td>
<td><p>Plots a phase portrait from last integration.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_result</span></code>(self, \*\*kwargs)</p></td>
<td><p>Plots the integrated dependent variables from last integration.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">post_process</span></code>(self, xout, yout, params)</p></td>
<td><p>Transforms internal values to output, used internally.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pre_process</span></code>(self, xout, y0[, params])</p></td>
<td><p>Transforms input to internal values, used internally.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">predefined</span></code>(self, y0, xout[, params])</p></td>
<td><p>Integrate with user chosen output.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">stiffness</span></code>(self[, xyp, eigenvals_cb])</p></td>
<td><p>[DEPRECATED] Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.stiffness()</span></code>, stiffness ration</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 73%" />
<col style="width: 27%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>all_invariant_names</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>all_invariants</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>as_autonomous</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_first_step_callback</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_invariants_callback</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>to_arrays</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyodesys.symbolic.TransformedSys.from_callback">
<em class="property">classmethod </em><code class="sig-name descname">from_callback</code><span class="sig-paren">(</span><em class="sig-param">cb</em>, <em class="sig-param">ny=None</em>, <em class="sig-param">nparams=None</em>, <em class="sig-param">dep_transf_cbs=None</em>, <em class="sig-param">indep_transf_cbs=None</em>, <em class="sig-param">roots_cb=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#TransformedSys.from_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.TransformedSys.from_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instance from a callback.</p>
<p>Analogous to <a class="reference internal" href="#pyodesys.symbolic.SymbolicSys.from_callback" title="pyodesys.symbolic.SymbolicSys.from_callback"><code class="xref py py-func docutils literal notranslate"><span class="pre">SymbolicSys.from_callback()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cb</strong><span class="classifier">callable</span></dt><dd><p>Signature <code class="docutils literal notranslate"><span class="pre">rhs(x,</span> <span class="pre">y[:],</span> <span class="pre">p[:])</span> <span class="pre">-&gt;</span> <span class="pre">f[:]</span></code></p>
</dd>
<dt><strong>ny</strong><span class="classifier">int</span></dt><dd><p>length of y</p>
</dd>
<dt><strong>nparams</strong><span class="classifier">int</span></dt><dd><p>length of p</p>
</dd>
<dt><strong>dep_transf_cbs</strong><span class="classifier">iterable of pairs callables</span></dt><dd><p>callables should have the signature <code class="docutils literal notranslate"><span class="pre">f(yi)</span> <span class="pre">-&gt;</span> <span class="pre">expression</span></code> in yi</p>
</dd>
<dt><strong>indep_transf_cbs</strong><span class="classifier">pair of callbacks</span></dt><dd><p>callables should have the signature <code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">-&gt;</span> <span class="pre">expression</span></code> in x</p>
</dd>
<dt><strong>roots_cb</strong><span class="classifier">callable</span></dt><dd><p>Callback with signature <code class="docutils literal notranslate"><span class="pre">roots(x,</span> <span class="pre">y[:],</span> <span class="pre">p[:],</span> <span class="pre">backend=math)</span> <span class="pre">-&gt;</span> <span class="pre">r[:]</span></code>.
Callback should return untransformed roots.</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Keyword arguments passed onto <a class="reference internal" href="#pyodesys.symbolic.TransformedSys" title="pyodesys.symbolic.TransformedSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformedSys</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyodesys.symbolic.get_logexp">
<code class="sig-prename descclassname">pyodesys.symbolic.</code><code class="sig-name descname">get_logexp</code><span class="sig-paren">(</span><em class="sig-param">a=1</em>, <em class="sig-param">b=0</em>, <em class="sig-param">a2=None</em>, <em class="sig-param">b2=None</em>, <em class="sig-param">backend=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#get_logexp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.get_logexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function for use with :func:symmetricsys.</p>
<p>Creates a pair of callbacks for logarithmic transformation
(including scaling and shifting): <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">ln(a*x</span> <span class="pre">+</span> <span class="pre">b)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">number</span></dt><dd><p>Scaling (forward).</p>
</dd>
<dt><strong>b</strong><span class="classifier">number</span></dt><dd><p>Shift (forward).</p>
</dd>
<dt><strong>a2</strong><span class="classifier">number</span></dt><dd><p>Scaling (backward).</p>
</dd>
<dt><strong>b2</strong><span class="classifier">number</span></dt><dd><p>Shift (backward).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Pair of callbacks.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyodesys.symbolic.symmetricsys">
<code class="sig-prename descclassname">pyodesys.symbolic.</code><code class="sig-name descname">symmetricsys</code><span class="sig-paren">(</span><em class="sig-param">dep_tr=None</em>, <em class="sig-param">indep_tr=None</em>, <em class="sig-param">SuperClass=&lt;class 'pyodesys.symbolic.TransformedSys'&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/symbolic.html#symmetricsys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.symbolic.symmetricsys" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory function for creating symmetrically transformed systems.</p>
<p>Creates a new subclass which applies the same transformation for each dependent variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dep_tr</strong><span class="classifier">pair of callables (default: None)</span></dt><dd><p>Forward and backward transformation callbacks to be applied to the
dependent variables.</p>
</dd>
<dt><strong>indep_tr</strong><span class="classifier">pair of callables (default: None)</span></dt><dd><p>Forward and backward transformation to be applied to the
independent variable.</p>
</dd>
<dt><strong>SuperClass</strong><span class="classifier">class</span></dt><dd></dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Default keyword arguments for the TransformedSys subclass.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Subclass of SuperClass (by default <a class="reference internal" href="#pyodesys.symbolic.TransformedSys" title="pyodesys.symbolic.TransformedSys"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformedSys</span></code></a>).</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logexp</span> <span class="o">=</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">psimp</span><span class="p">(</span><span class="n">exprs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LogLogSys</span> <span class="o">=</span> <span class="n">symmetricsys</span><span class="p">(</span><span class="n">logexp</span><span class="p">,</span> <span class="n">logexp</span><span class="p">,</span> <span class="n">exprs_process_cb</span><span class="o">=</span><span class="n">psimp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mysys</span> <span class="o">=</span> <span class="n">LogLogSys</span><span class="o">.</span><span class="n">from_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mysys</span><span class="o">.</span><span class="n">exprs</span>
<span class="go">(-exp(x_0), -exp(x_0) + exp(x_0 + y_0 - y_1))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-pyodesys.util">
<span id="pyodesys-util-module"></span><h2>pyodesys.util module<a class="headerlink" href="#module-pyodesys.util" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyodesys.util.MissingImport">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.util.</code><code class="sig-name descname">MissingImport</code><span class="sig-paren">(</span><em class="sig-param">modname</em>, <em class="sig-param">exc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/util.html#MissingImport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.util.MissingImport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(self, \*args, \*\*kwargs)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyodesys.util.check_transforms">
<code class="sig-prename descclassname">pyodesys.util.</code><code class="sig-name descname">check_transforms</code><span class="sig-paren">(</span><em class="sig-param">fw</em>, <em class="sig-param">bw</em>, <em class="sig-param">symbs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/util.html#check_transforms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.util.check_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify validity of a pair of forward and backward transformations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fw: expression</strong></dt><dd><p>forward transformation</p>
</dd>
<dt><strong>bw: expression</strong></dt><dd><p>backward transformation</p>
</dd>
<dt><strong>symbs: iterable of symbols</strong></dt><dd><p>the variables that are transformed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyodesys.util.import_">
<code class="sig-prename descclassname">pyodesys.util.</code><code class="sig-name descname">import_</code><span class="sig-paren">(</span><em class="sig-param">modname</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/util.html#import_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.util.import_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyodesys.util.merge_dicts">
<code class="sig-prename descclassname">pyodesys.util.</code><code class="sig-name descname">merge_dicts</code><span class="sig-paren">(</span><em class="sig-param">*dicts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/util.html#merge_dicts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.util.merge_dicts" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges dictionaries with incresing priority.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*dicts: dictionaries</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d1</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd1</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd2</span> <span class="o">=</span> <span class="n">merge_dicts</span><span class="p">(</span><span class="n">dd1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">17</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd2</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">dd2</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">dd2</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">10</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyodesys.util.pycvodes_double">
<code class="sig-prename descclassname">pyodesys.util.</code><code class="sig-name descname">pycvodes_double</code><span class="sig-paren">(</span><em class="sig-param">cb</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/util.html#pycvodes_double"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.util.pycvodes_double" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyodesys.util.pycvodes_klu">
<code class="sig-prename descclassname">pyodesys.util.</code><code class="sig-name descname">pycvodes_klu</code><span class="sig-paren">(</span><em class="sig-param">cb</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/util.html#pycvodes_klu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.util.pycvodes_klu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyodesys.util.requires">
<em class="property">class </em><code class="sig-prename descclassname">pyodesys.util.</code><code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param">*reqs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/util.html#requires"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.util.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Conditional skipping (on requirements) of tests in pytest</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@requires</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test_sqrt</span><span class="p">():</span>
<span class="gp">... </span>    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
<span class="gp">... </span>    <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">zeta</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">zeta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@requires</span><span class="p">(</span><span class="s1">&#39;numpy&gt;=1.9.0&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test_nanmedian</span><span class="p">():</span>
<span class="gp">... </span>    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">... </span>    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
<span class="gp">...</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(self, cb)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.util.requires.eq" title="pyodesys.util.requires.eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eq</span></code></a>()</p></td>
<td><p>eq(a, b) – Same as a==b.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.util.requires.ge" title="pyodesys.util.requires.ge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ge</span></code></a>()</p></td>
<td><p>ge(a, b) – Same as a&gt;=b.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.util.requires.gt" title="pyodesys.util.requires.gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gt</span></code></a>()</p></td>
<td><p>gt(a, b) – Same as a&gt;b.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.util.requires.le" title="pyodesys.util.requires.le"><code class="xref py py-obj docutils literal notranslate"><span class="pre">le</span></code></a>()</p></td>
<td><p>le(a, b) – Same as a&lt;=b.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyodesys.util.requires.lt" title="pyodesys.util.requires.lt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lt</span></code></a>()</p></td>
<td><p>lt(a, b) – Same as a&lt;b.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyodesys.util.requires.ne" title="pyodesys.util.requires.ne"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ne</span></code></a>()</p></td>
<td><p>ne(a, b) – Same as a!=b.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyodesys.util.requires.eq">
<code class="sig-name descname">eq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyodesys.util.requires.eq" title="Permalink to this definition">¶</a></dt>
<dd><p>eq(a, b) – Same as a==b.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.util.requires.ge">
<code class="sig-name descname">ge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyodesys.util.requires.ge" title="Permalink to this definition">¶</a></dt>
<dd><p>ge(a, b) – Same as a&gt;=b.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.util.requires.gt">
<code class="sig-name descname">gt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyodesys.util.requires.gt" title="Permalink to this definition">¶</a></dt>
<dd><p>gt(a, b) – Same as a&gt;b.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.util.requires.le">
<code class="sig-name descname">le</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyodesys.util.requires.le" title="Permalink to this definition">¶</a></dt>
<dd><p>le(a, b) – Same as a&lt;=b.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.util.requires.lt">
<code class="sig-name descname">lt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyodesys.util.requires.lt" title="Permalink to this definition">¶</a></dt>
<dd><p>lt(a, b) – Same as a&lt;b.</p>
</dd></dl>

<dl class="method">
<dt id="pyodesys.util.requires.ne">
<code class="sig-name descname">ne</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyodesys.util.requires.ne" title="Permalink to this definition">¶</a></dt>
<dd><p>ne(a, b) – Same as a!=b.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyodesys.util.stack_1d_on_left">
<code class="sig-prename descclassname">pyodesys.util.</code><code class="sig-name descname">stack_1d_on_left</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/util.html#stack_1d_on_left"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.util.stack_1d_on_left" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack a 1D array on the left side of a 2D array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: 1D array</strong></dt><dd></dd>
<dt><strong>y: 2D array</strong></dt><dd><p>Requirement: <code class="docutils literal notranslate"><span class="pre">shape[0]</span> <span class="pre">==</span> <span class="pre">x.size</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyodesys.util.transform_exprs_dep">
<code class="sig-prename descclassname">pyodesys.util.</code><code class="sig-name descname">transform_exprs_dep</code><span class="sig-paren">(</span><em class="sig-param">fw</em>, <em class="sig-param">bw</em>, <em class="sig-param">dep_exprs</em>, <em class="sig-param">check=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/util.html#transform_exprs_dep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.util.transform_exprs_dep" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform y[:] in dydx</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fw: expression</strong></dt><dd><p>forward transformation</p>
</dd>
<dt><strong>bw: expression</strong></dt><dd><p>backward transformation</p>
</dd>
<dt><strong>dep_exprs: iterable of (symbol, expression) pairs</strong></dt><dd><p>pairs of (dependent variable, derivative expressions),
i.e. (y, dydx) pairs</p>
</dd>
<dt><strong>check: bool (default: True)</strong></dt><dd><p>whether to verification of the analytic correctness should
be performed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>List of transformed expressions for dydx</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyodesys.util.transform_exprs_indep">
<code class="sig-prename descclassname">pyodesys.util.</code><code class="sig-name descname">transform_exprs_indep</code><span class="sig-paren">(</span><em class="sig-param">fw</em>, <em class="sig-param">bw</em>, <em class="sig-param">dep_exprs</em>, <em class="sig-param">indep</em>, <em class="sig-param">check=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyodesys/util.html#transform_exprs_indep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyodesys.util.transform_exprs_indep" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform x in dydx</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fw: expression</strong></dt><dd><p>forward transformation</p>
</dd>
<dt><strong>bw: expression</strong></dt><dd><p>backward transformation</p>
</dd>
<dt><strong>dep_exprs: iterable of (symbol, expression) pairs</strong></dt><dd><p>pairs of (dependent variable, derivative expressions)</p>
</dd>
<dt><strong>check: bool (default: True)</strong></dt><dd><p>whether to verification of the analytic correctness should
be performed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>List of transformed expressions for dydx</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pyodesys.native.html" class="btn btn-neutral float-right" title="pyodesys.native package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Welcome to pyodesys’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Bjoern I. Dahlgren &lt;bjodah@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.12.6',
            LANGUAGE:'en',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>